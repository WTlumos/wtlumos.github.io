<!DOCTYPE html>
<html lang="zh-CN,en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wtlumos.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C语言集训营——关键字，常量，变量，数据类型，输入输出，运算符与表达式，选择结构程序设计，函数，结构体">
<meta property="og:type" content="article">
<meta property="og:title" content="王道C语言">
<meta property="og:url" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="W.T.的博客">
<meta property="og:description" content="C语言集训营——关键字，常量，变量，数据类型，输入输出，运算符与表达式，选择结构程序设计，函数，结构体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/obj.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/cinstall.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/chineseinstall.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/new1.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/new2.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile1.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile5.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile2.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile3.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile4.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/codelldb.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/data1.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/ascii.jpeg">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/char.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/int-char-float.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/result.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/result2.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/free.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/scanf.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/printf.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/priority.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/func.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/all.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/struct.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/file.png">
<meta property="og:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/a.txt.png">
<meta property="article:published_time" content="2018-01-23T05:38:51.000Z">
<meta property="article:modified_time" content="2023-04-15T08:18:14.769Z">
<meta property="article:author" content="Wang Ting">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/obj.png">

<link rel="canonical" href="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>王道C语言 | W.T.的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">W.T.的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Every day to be a little better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        
            
  <li class="menu-item menu-item-books">
      
    

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书单</a>

  </li>


      
        <li class="menu-item menu-item-route">
      
    

    <a href="/route/" rel="section"><i class="fas fa-route fa-fw"></i>学习路线</a>

  </li>
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-language">

    <a href="/en" rel="section"><i class="fas fa-language fa-fw"></i>English</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/WTlumos" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wang Ting">
      <meta itemprop="description" content="技术成长笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="W.T.的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          王道C语言
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-23 13:38:51" itemprop="dateCreated datePublished" datetime="2018-01-23T13:38:51+08:00">2018-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-15 16:18:14" itemprop="dateModified" datetime="2023-04-15T16:18:14+08:00">2023-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote class="blockquote-center">C语言集训营——关键字，常量，变量，数据类型，输入输出，运算符与表达式，选择结构程序设计，函数，结构体</blockquote>

<span id="more"></span>

<h1 id="C语言">1. C语言</h1><p>C语言为什么叫C语言呢？其实是因为先有高级语言ALGOL60(A语言)，后来它经过简化变为BCPL语言(B语言)，而C语言是在B语言的基础之上发展而来的，所以称之为C语言。在世界上第一个C语言编译器是用B语言编写的。目前，主流的编译器是微软公司的Visual Studio使用的masm编辑器和Linux使用的gcc编译器。学习一堆关于C的版本和标准意义不大，关键是要掌握编辑器支持的语言特性</p>
<h2 id="UNIX">1.1. UNIX</h2><p><code>1965</code>年前，计算机并不像今天这样普遍，它不是普通人能用得起的，除非是军事机构或学院研究机构。当时，大型主机最多能支持30个终端(30个键盘，显示器)，为了解决终端数量不足的问题，1965年前后，贝尔实验室加入麻省理工学院和通用电气公司的合作计划，以便建立一套多用户，多处理器，多层次的MULTICS操作系统，让大型主机支持300个终端。</p>
<p><code>1965</code>年前后，该项目进展缓慢，资金短缺，贝尔实验室退出实验室。1969年8月，从这个项目中退出的Ken Thompson 为了能在实验室中一台空闲的计算机上运行“星际旅行(Space Travel)“游戏，在妻子探亲的1个月时间内，使用汇编语言编写了UNIX操作系统的原型。</p>
<p><code>1970</code>年，Ken Thompson 以BCPL语言为基础，设计出了很简单且接近硬件的B语言，并且B语言编写了第一个UNIX操作系统。</p>
<p><code>1971</code>年，同样酷爱“星级旅行”的Dennis M.Ritchie 为了能早一些玩上这款游戏，加入了Ken Thompson的开发项目，合作开发了UNIX操作系统。他的主要工作是改造B语言，因为B语言跨平台性较差。</p>
<p><code>1972</code>年，Dennis M.Ritchie 在B语言的基础上最终设计出了一种新语言，他以BCPL的第二个字母作为这种语言的名字，这就是C语言。</p>
<p><code>1973</code>年初，C语言的主体完成，Ken Thompson 和 Dennis M.Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的UNIX操作系统。</p>
<h2 id="C">1.2. C</h2><p>在把UNIX操作系统移植到其他类型的计算机上使用时，C语言强大的移植性得以显现。机器语言和汇编语言都不具有移植性，为x86开发的程序，不可能在Alpha，SPARC和ARM等机器上运行。而C程序则可以在任意架构的处理器上使用，只要这种架构的处理器具有对应的C语言编译器和库，将C源代码编译，链接成目标二进制文件即可运行。</p>
<p><code>跨平台</code> 无须修改即可在任何平台上运行。如：java，python</p>
<p><code>可移植</code> 可以通过不同的编译器编译后在任何平台上运行。</p>
<p>C语言是可移植不可跨平台的语言。因为C语言除文件操作外，还未涉及到<code>操作系统硬件资源的接口</code>，如进程调度，网络通信等，这些接口均是每个操作系统独有的，因为Windows和Linux的这些接口有所差异。一旦C程序中使用了这些接口，将代码放到另一个平台上就无法编译通过。</p>
<p><code>那么C语言就不如Java语言？</code></p>
<p>不然，WIndows操作系统本身使用C&#x2F;C++和少量的汇编语言开发的，Linux是用C和少量汇编语言开发的，C语言执行效率在高级语言中一直位居第一。另外，Java语言及其他脚本语言中没有指针，无法访问物理地址，所以系统中的驱动都要用C或C++语言进行编写。</p>
<h2 id="编译过程">1.3. 编译过程</h2><p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/obj.png"></p>
<p>首先编写源程序f.c。编写完毕后，通过编译器进行编译，这里的编译包括预处理，编译，汇编。详情请阅读编译原理的书籍。f.c经过编译后，得到f.obj文件，f.obj文件由均是0&#x2F;1类型的机器码，即CPU能够识别的微指令。f.obj文件并不能执行，因为我们调用的标准库函数的代码并不在f.obj文件中。如输出函数printf，并不会在f.obj中，这时经过链接就得到可执行文件f.exe。了解这个编译过程，后面在编写程序遇到编译错误时，就可以分析错误，进而区分是编译错误还是链接错误。</p>
<h2 id="学习C语言后的境界">1.4. 学习C语言后的境界</h2><p>达到的效果是理解程序的执行过程，对于理解程序的执行过程，C语言是当之无愧的最佳选择，因为其他高级语言封装的内容太多，程序执行的过程是什么？其实，<code>程序执行的过程简单来说就是内存的变化过程</code>。打个比方：内存的变化过程就像衣柜的变化过程，通过内存来存储数据，就像通过衣柜来存储衣服。数据存储要有规律，以便高效取出；衣服存放要有次序，否则可能会花很长时间找想要的那件衣服，当然，程序员的级别更高级，更像裁缝，衣柜里所放的原始布料相当于做好的衣服有规律地放在衣柜中，以便需要时提供给客户；程序员也需要把处理好的数据放好，以便在用户需要时显示给用户。</p>
<p>另外要掌握的能力是程序的调试能力，要灵活掌握单步调试，判断打印等手段，要能在清晰理解程序执行过程的基础上准确分析数据的变化过程，定位程序的问题点，进而解决问题。学好了C语言，以后在学习其他任何语言并调试程序的问题时就会事半功倍。</p>
<h1 id="编译软件VSCode">2. 编译软件VSCode</h1><h2 id="下载软件">2.1. 下载软件</h2><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>
<h2 id="安装插件">2.2. 安装插件</h2><p>C&#x2F;C++</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/cinstall.png"></p>
<p>中文语言包</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/chineseinstall.png"></p>
<h2 id="新建文档">2.3. 新建文档</h2><p>打开VSCode首页添加工作区间，新建文档 test.c</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/new1.png"></p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/new2.png"></p>
<h2 id="启动编译">2.4. 启动编译</h2><p>选择左侧的【运行和调试】，选择环境【C++(GDB&#x2F;LLDB)】，【gcc】</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile1.png"></p>
<p>运行终端出现【终端将被任务重用，按任意键关闭】</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile5.png"></p>
<p>在文件夹中出现了【tasks.json】，在文档中加上presentation，其中的panel属性可以用shared和new，shared表示终端共享使用，new的话就是再建一个终端来显示</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile2.png"></p>
<p>此时可以正常显示</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile3.png"></p>
<p>并可以正常输出</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/compile4.png"></p>
<h2 id="支持scanf函数">2.5. 支持scanf函数</h2><p>搜索【codelldb】，进行安装</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/codelldb.png"></p>
<p>修改<code>launch.json</code>，文件位于文件夹的【.vscode】中</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     &quot;name&quot;: &quot;gcc - 生成和调试活动文件&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;type&quot;: &quot;cppdbg&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;request&quot;: &quot;launch&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;args&quot;: [],</span></span><br><span class="line">        <span class="comment">//     &quot;stopAtEntry&quot;: false,</span></span><br><span class="line">        <span class="comment">//     &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;environment&quot;: [],</span></span><br><span class="line">        <span class="comment">//     &quot;externalConsole&quot;: false,</span></span><br><span class="line">        <span class="comment">//     &quot;MIMode&quot;: &quot;lldb&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;preLaunchTask&quot;: &quot;C/C++: gcc 生成活动文件&quot;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看内存信息">2.6. 查看内存信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_memory</span><span class="params">(<span class="type">void</span> *start, <span class="type">int</span> memory_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p = (<span class="type">char</span> *)start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; memory_len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p &quot;</span>, p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, (p[i] &amp; <span class="number">0x000000f0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, p[i] &amp; <span class="number">0x0000000f</span>);</span><br><span class="line">    <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> data[<span class="number">3</span>];</span><br><span class="line">  data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  data[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  data[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  0x7ffee45d868c 01 00 00 00 </span></span><br><span class="line"><span class="comment">  0x7ffee45d8690 02 00 00 00 </span></span><br><span class="line"><span class="comment">  0x7ffee45d8694 03 00 00 00 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">show_memory</span>(data, <span class="built_in">sizeof</span>(data));</span><br><span class="line">  <span class="type">float</span> f = <span class="number">1.456</span>;</span><br><span class="line">  <span class="comment">// 0x7ffee07e9684 35 5e ba 3f </span></span><br><span class="line">  <span class="built_in">show_memory</span>(&amp;f, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查看汇编代码和机器码">2.7. 查看汇编代码和机器码</h2><p><strong>项目执行过程：</strong></p>
<blockquote>
<p>C文件预处理变为i文件</p>
<p>i文件经过编译变为s文件 - 汇编文件</p>
<p>s文件经过汇编变为obj文件 - 目标文件</p>
<p>obj文件经过链接变为exe文件 - 可执行文件</p>
</blockquote>
<p>终端输入以下命令可以得到汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.c</span><br></pre></td></tr></table></figure>

<p>得到汇编+机器码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o main main.c</span><br><span class="line">objdump -d main &gt; main.dump</span><br></pre></td></tr></table></figure>



<h1 id="在线语言包">3. 在线语言包</h1><p><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a></p>
<h1 id="关键字">4. 关键字</h1><p>C语言中有许多关键字。关键字有特殊的用途，<code>不能用于变量命名</code></p>
<table>
<thead>
<tr>
<th>auto</th>
<th>const</th>
<th>double</th>
<th>float</th>
<th>int</th>
<th>short</th>
<th>struct</th>
<th>unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>continue</td>
<td>else</td>
<td>for</td>
<td>long</td>
<td>signed</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>case</td>
<td>default</td>
<td>enum</td>
<td>goto</td>
<td>register</td>
<td>sizeof</td>
<td>typedef</td>
<td>volatile</td>
</tr>
<tr>
<td>char</td>
<td>do</td>
<td>extern</td>
<td>if</td>
<td>return</td>
<td>static</td>
<td>union</td>
<td>while</td>
</tr>
</tbody></table>
<h1 id="常量">5. 常量</h1><p>常量是指在程序运行过程中，其值不发生变化的量。常量又可分为整型，实型，字符型和字符串型。</p>
<p>整型常量，实型常量，字符常量是在编译时可以直接编入代码段的常量，字符串型常量是指存放在字符串型常量区中的常量，例如，在字符串“你好”中，双引号中间的汉子就是字符串常量，无论双引号中间的内容是ASCII码字符，还是汉字或其他国家的文字等，都是字符串型常量。</p>
<blockquote>
<p>整型 100,125,-100,0</p>
<p>实型 3.14,0.125,-3.789</p>
<p>字符型 ‘a’,’b’,’c’</p>
<p>字符串型 “a”,”abc”</p>
</blockquote>
<h1 id="变量">6. 变量</h1><h2 id="含义">6.1. 含义</h2><p><code>变量</code>代表内存中具有特定属性的一个存储单元，它用来存放数据，即变量的值。这些值在程序的执行过程中是可以改变的。</p>
<p><code>变量名</code>以一个名字代表一个对应的存储单元地址。编译，链接程序时，由编译系统为每个变量名分配对应的内存地址。从变量中取值实际上是通过变量名找到内存中存储单元的地址，并从该存储单元中读取数据。</p>
<p><code>int a = 3;</code> a就是变量名，s就是变量值，int就是变量存储类型</p>
<h2 id="命名规则">6.2. 命名规则</h2><ol>
<li><p>C语言规定标识符只能由<code>字母，数字和下划线</code>三种字符组成，并且<code>第一个</code>字符必须为<code>字母或下划线</code>。</p>
<p><code>3D64</code>就是 错误的</p>
</li>
<li><p>C语言区分大小写</p>
</li>
<li><p>C语言要求强制定义。即每个变量必须声明后定义值</p>
</li>
<li><p>变量的命名应该做到<code>见名知意</code>，即选择具有含义的英文单词作为标识符，且不能与关键字同名</p>
</li>
</ol>
<h1 id="数据类型">7. 数据类型</h1><p>裁缝做衣服时需要用到化纤，纯棉，丝绸等不同类型的布料，程序员在编写程序时需要用到各种数据类型，数据类型分为：</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/data1.png"></p>
<h2 id="整型变量">7.1. 整型变量</h2><h3 id="符号常量">7.1.1. 符号常量</h3><p>定义一个整型变量时要使用关键字int。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//123是整型常量，赋值给变量i</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line">  i = PI*<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//常量不可修改，此句解除主食会无法编译通过</span></span><br><span class="line">  PI=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PI=%d\n&quot;</span>,PI);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于整型变量<code>i</code>有自己的内存空间，因此既可以存储整型常量<code>123</code>，又可以存储<code>PI*2</code>，也就是<code>3*2</code>，由<code>define</code>定义的PI为什么是常量呢？</p>
<p><code>预处理时会清除所有的define</code>，用define将PI定义为3，编译器在预处理后会把代码中出现的所有常量都替换为3，所以PI为常量，不可修改。</p>
<h3 id="不同进制表示">7.1.2. 不同进制表示</h3><p>计算机中只能存储二进制数，即0和1，而在对应的物理硬件上则是高低电平，为了更方便地观察内存中的二进制情况，除正常使用的二进制外，计算机还提供了十六进制和八进制数。</p>
<p>首先，在计算机中，1字节为8位，1位即二进制的1位，它存储0或1，int型常量的大小为4字节，即32位。</p>
<p>设有二进制<code>0100 1100 0011 0001 0101 0110 1111 1110</code>，其最低位是2的零次方，最高位是2的30次方，最高位为符号位。</p>
<p>其对应的八进制数是<code>011414253376</code>,它以0开头标示，数位的变化范围是0-7，二进制转换为八进制数的方式是，对应的二进制每3位转换为1位八进制数，首先将上面的二进制数按每3 位隔开，得到<code>01 001 100 001 100 010 101 011 011 111 110</code>，然后每3位对应0-7范围内的数进行对应转转，得到八进制数<code>011414253376</code>，由于实际编程时，识别八进制时前面需要加0，所以在前面加了一个0。</p>
<p>其对应的十进制是<code>1278301950</code></p>
<p>其对应的十六进制是<code>0x4c3156FE</code>，它以<code>0x</code>开头标示，数位的变化范围是0-9和A-F，其中A代表10，F代表15，对应的二进制数每4位转换为1位十六进制。</p>
<h3 id="6种整型变量类型">7.1.3. 6种整型变量类型</h3><p>整型变量包括6种类型，其中有符号基本整型与无符号基本整型的最高位所代表的意义不同。</p>
<p>不同整型变量表示的整型数的范围不同，超出范围会发生溢出现象，导致计算出错。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类型说明符</th>
<th>长度</th>
<th>整型数的范围</th>
</tr>
</thead>
<tbody><tr>
<td>有符号基本整型</td>
<td>(signed) int</td>
<td>4字节</td>
<td>-$2^{31}$ ~ $2^{31}$-1</td>
</tr>
<tr>
<td>有符号短整型</td>
<td>(signed) short (int)</td>
<td>2字节</td>
<td>-$2^{15}$ ~ $2^{15}$-1</td>
</tr>
<tr>
<td>有符号基本整型</td>
<td>(signed) long (int)</td>
<td>4字节(64位为8字节)</td>
<td>-$2^{31}$ ~ $2^{31}$-1 或 -$2^{63}$ ~ $2^{63}$-1</td>
</tr>
<tr>
<td>无符号基本整型</td>
<td>unsigned int</td>
<td>4字节</td>
<td>0 ~ $2^{32}$-1</td>
</tr>
<tr>
<td>无符号短整型</td>
<td>unsigned short (int)</td>
<td>2字节</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>无符号长整型</td>
<td>unsigned long (int)</td>
<td>4字节(64位为8字节)</td>
<td>0 ~ $2^{32}$-1 或 0 ~ $2^{64}$-1</td>
</tr>
</tbody></table>
<p><code>溢出情况</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">short</span> a = <span class="number">32767</span>;</span><br><span class="line">  <span class="type">short</span> b = a+<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// -32768</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有符号短整型可以表示的最大值为32767，当对其加1时，b的值等于-32768，为什么会这样？</p>
<p>因为32767对应的十六进制数为0X7fff，加1后变为0x8000，其首位为1，因此变成了一个负数，取这个负数的原码后，就是其本身的值32768，所以0X8000是最小的负数，即-32768，这时就发生了溢出，对32767加1，希望得到的值是32768，但结果却是-32768，因此导致计算结果错误，在使用整型变量时，一定要注意数值的大小，数值不能超过对应整型数的表示范围。</p>
<p>如果在编写的程序汇总数值大于$2^{64}$-1时怎么办？</p>
<p>答案是可以使用数组来存储数值。</p>
<h2 id="浮点型数据">7.2. 浮点型数据</h2><h3 id="浮点型常量">7.2.1. 浮点型常量</h3><p>表示浮点常量的形式有两种</p>
<table>
<thead>
<tr>
<th>小数部分</th>
<th>0.123</th>
</tr>
</thead>
<tbody><tr>
<td>指数形式</td>
<td>3e-3(3x10${^{-3}}$)，即0.003</td>
</tr>
</tbody></table>
<p>字母e或E代表10的幂次，幂次可正可负。<code>e前面必须有数字，e后面的指数必须为整数</code></p>
<p>正确示例：1e3，1.8e-3，-123e-6，-.1e-3</p>
<p>错误示例：e3，2.1e3.5，.e3，e</p>
<h3 id="浮点数精度控制">7.2.2. 浮点数精度控制</h3><p>浮点型变量分为单精度(float)型，双精度(double)型和长双精度(long double)型三类。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>数值范围</th>
<th>有效数字</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>32</td>
<td>$10^{-37}$~$10^{38}$</td>
<td>6~7位</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>$10^{-307}$~$10^{308}$</td>
<td>15~16位</td>
</tr>
<tr>
<td>long double</td>
<td></td>
<td>$10^{-4931}$~$10^{4932}$</td>
<td>18~19位</td>
</tr>
</tbody></table>
<p>因为浮点数使用的是指数表示法，所以不用担心数值的范围，也不用去看浮点数的内存。需要注意的是浮点数的精度问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">1.23456789e10</span>;</span><br><span class="line">  <span class="type">float</span> b = a+<span class="number">20</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋给a的值为1.23456789e10，加20后，应该得到的值为1.234567892e10，但结果却是1.23456788e+010，变得更小了，这种现象就称为精度丢失，因为float型数据能够表示的有效数字为7位，最多只保证1.23456e10的正确性，要使结果正确，就需要把a和b均改为double型。</p>
<h3 id="浮点型变量">7.2.3. 浮点型变量</h3><p>一般通过&#96;float f，double d来定义浮点变量，f占用4个字节空间，d占用8个字节空间。与整型数据的存储方式不同，浮点型数据是按照指数形式存储的，系统把一个浮点型数据分成小数部分(用M表示)和指数部分(用E表示)并分别存放，指数部分采用IEEE754规范化的指数形式，指数也分正负(符号位，用S表示)</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>符号位</th>
<th>指数部分(阶码)</th>
<th>小数部分(尾数码)</th>
<th>总位数</th>
<th>偏置值</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
<td>7FH</td>
</tr>
<tr>
<td>double</td>
<td>1</td>
<td>11</td>
<td>52</td>
<td></td>
<td>3FFH</td>
</tr>
</tbody></table>
<p><code>IEEE-754浮点型存储标准</code></p>
<p>以4.5为例，4.5D&#x3D;100.1B&#x3D;1.001x$2^2$B</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>SEEEEEEE</th>
<th>EMMMMMMM</th>
<th>MMMMMMMM</th>
<th>MMMMMMMM</th>
</tr>
</thead>
<tbody><tr>
<td>二进制数</td>
<td>01000000</td>
<td>100010000</td>
<td></td>
<td>00000000</td>
</tr>
<tr>
<td>十六进制数</td>
<td>40</td>
<td>90</td>
<td></td>
<td>00</td>
</tr>
</tbody></table>
<p><code>S：S符号位</code>，用来表示正，负，是1时代表负数，是0时代表正数。</p>
<p><code>E：E代表指数部分</code>，在IEEE-754浮点数标准中的阶码是用移码表示的，移码&#x3D;真值+偏置值，偏置值&#x3D;$2^{n-1}$-1，8位的移码的偏置值为$2^{8-1}$-1&#x3D;127D&#x3D;0111,1111B，故阶码&#x3D;0000,0010B+0111,1111B&#x3D;1000,0001B。所以，还原时指数部分运算前都要减去127，这里的10000001转换为十进制数为129，129-127&#x3D;2，即实际指数部分为2。</p>
<p><code>M：M代表小数部分</code>，在IEEE-754标准中的尾数码部分是用原码表示的，且尾数码隐含了最高位1，在计算中需要加上最高位1，即1.M。这里为0010 0000 0000 0000 0000 000。底部左边省略存储了一个1，使用的实际底数表示为1.00100000000000000000000。</p>
<p>反向推导：</p>
<p>计算机并不能计算10的幂次，指数值为2，代表2的2次幂，因此将1.001向左移动2位即可，也就是100.1；然后转换为十进制数，整数部分为4，小数部分为$2^{-1}$，刚好等于0.5，因此十进制为4.5。浮点数的小数部分通过$2^{-1}$+$2^{-2}$+$2^{-3}$+…来近似一个小数的</p>
<h2 id="字符型数据">7.3. 字符型数据</h2><h3 id="字符型常量">7.3.1. 字符型常量</h3><p>用<code>单引号</code>括起来的一个字符是字符型常量，且只能包含一个字符，例如，‘a’，‘A’，’1‘是正确的字符型常量，而“abc”，“a”是错误的字符型常量，以<code>\</code>开头的特殊字符称为转义字符，转义字符用来表示回车，退格等功能键。</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>横向跳格</td>
</tr>
<tr>
<td>\0</td>
<td>空字母，用于标示字符串的结尾，但它不是空格，无法打印</td>
</tr>
<tr>
<td>\ddd</td>
<td>ddd表示1-3位八进制数</td>
</tr>
<tr>
<td>\xhh</td>
<td>hh表示1-2位十六进制数</td>
</tr>
</tbody></table>
<p>例如 <code>abc\rd打印出来的效果是dbc</code></p>
<h3 id="ASCII码表">7.3.2. ASCII码表</h3><p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/ascii.jpeg"></p>
<h3 id="字符数据在内存中的存储形式及其使用方法">7.3.3. 字符数据在内存中的存储形式及其使用方法</h3><p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/char.png"></p>
<p>字符型变量使用关键字char进行定义，一个字符型变量占用1字节的空间，一个字符常量存放到一个字符型变量，实际上并不是把该字符的字型放到内存中，而是把该字符的ASCII码值放到存储单元中。打印字符型变量时，如果以字符形式打印，那么计算机会到ASCII码表中查找字符型变量的ASCII码值，查到对应的字符后会显示对应的字符，这样，字符型数据和整型数据之间就可以通用。字符型数据既可以以字符形式输出，又可以以整数形式输出，还可以通过运算获取想要的各种字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch1,ch2;</span><br><span class="line">    ch1 = <span class="number">97</span>;</span><br><span class="line">    ch2=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">//打印的都是字母a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1=%c ch2=%c\n&quot;</span>,ch1,ch2);</span><br><span class="line">    <span class="comment">//打印的都是数字97</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1=%d ch2=%d\n&quot;</span>,ch1,ch2);</span><br><span class="line">    <span class="comment">//小写转大写 a-&gt;A</span></span><br><span class="line">    ch1 = ch1<span class="number">-32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1=%c\n&quot;</span>,ch1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于字符型变量，无论是赋ASCII码值还是赋字符，使用%c打印输出时得到的都是字符，使用%d打印输出时得到的都是ASCII码值，将小写字母转换为大写字母时，小写字母比大写字母数值大32。</p>
<h3 id="字符串型常量">7.3.4. 字符串型常量</h3><p>字符串型常量是由一对双引号括起来的字符序列，例如，”How do you do”，可用语句<code>printf(&quot;How do you do&quot;)</code>输出一个字符串，但要注意的是，‘a’是字符型常量，而“a”是字符串型常量，二者不同。</p>
<p>C语言规定，在每个字符串常量的结尾加一个字符串结束标志，以便系统据此判断字符串是否结束。C语言规定以字符’\0’作为字符串结束标志。</p>
<p>例如，字符串常量”CHINA”在内存中的存储结果为</p>
<table>
<thead>
<tr>
<th>C</th>
<th>H</th>
<th>I</th>
<th>N</th>
<th>A</th>
<th>\0</th>
</tr>
</thead>
</table>
<h2 id="混合运算">7.4. 混合运算</h2><p>字符型(char)，整型(int&#x2F;short&#x2F;long)，浮点型(float&#x2F;double)数据可以混合运算，运算时，不同类型的数据首先要转换为同一类型，然后进行运算。</p>
<p>不同类型数据的转换级别不同</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/int-char-float.png"></p>
<p>从短字节到长字节的类型转换是由系统自动进行的，编译时不会给出警告；若反向进行，则编译时编译器会给出警告。</p>
<h3 id="数值按int型运算">7.4.1. 数值按int型运算</h3><p>C语言中的整型数算术运算总是以默认整型类型的精度进行的，为了获得这个精度，表达式中的字符型和短整型操作数在使用之前会被转换为基本整型(int型)操作数，这种转换被称为整型提升(Integral Promotion)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a,b,c;</span><br><span class="line">a = b + c;</span><br></pre></td></tr></table></figure>

<p>其中，b和c的值首先被提升为基本整型数，然后执行加法运算。加法运算的结果将被截短，然后存放到a中，这个例子的结果和使用8位算术运算的结果相同。</p>
<p>但是下列的代码结果默认按照int型运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">0x93</span>&lt;&lt;<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// ffffff93</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line">  b = <span class="number">0x93</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  b = b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 13</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>为什么采用十六进制打印呢？</code></p>
<p>这是因为输出时%x是取4字节进行输出的；如果用%d输出，那么可以得到一个负值，用%x输出一个少于4字节的数时，前面补的字节是按照对应数据的最高位来看的，因为字符b的最高位为1，所以其他3字节补的是1，打印出3字节的ff。</p>
<p><code>为什么把操作分成两步后，b的值就为13？</code></p>
<p>因为0x93左移移位时，虽然按4字节进行，但是最低一字节的值为0x26。赋值给b后，b内存储的就是0x26，这时再对b进行右移时，单字节拿到寄存器中是按照4字节运算的，但是因为b的最高位为零，因此拿到寄存器中按照4字节运算，前面补的都是零，再右移移位表示除以2，因此得到的值是13。</p>
<p>另外一个场景是两个整型常量做乘法，并赋值给一个长整型变量，对编译器来讲这是按照int型进行的。当两个整型常量值太大时，结果会溢出，无论是在VS中新建Win32控制台应用程序并在32位下执行，还是Linux下将其编译为64位的可执行程序，执行结果均为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">  l = <span class="number">131072</span> * <span class="number">131072</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>如何解决溢出？</code></p>
<p>在乘法之前，将整型数强制转换为long型，在32位操作系统下，long long型占8字节而long型占4字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> l;</span><br><span class="line">  l = (<span class="type">long</span> <span class="type">long</span>)<span class="number">131072</span> * <span class="number">131072</span>;</span><br><span class="line">  <span class="comment">// 17179869184</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在64位程序，Linux操作系统下，转化为long型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">  l = (<span class="type">long</span>)<span class="number">131072</span> * <span class="number">131072</span>;</span><br><span class="line">  <span class="comment">// 17179869184</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="浮点型常量默认按double型运算">7.4.2. 浮点型常量默认按double型运算</h3><p>浮点型常量默认按8字节运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">12345678900.0</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="type">double</span> d = f;</span><br><span class="line">  <span class="comment">// 12345678848.000000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,f);</span><br><span class="line">  <span class="comment">// 12345678901.000000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">12345678900.0</span>+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个打印的值只有7位精度，原因是单精度浮点数f只有4字节的存储空间，能够表示的精度是6<del>7位，所以只保证1</del>7位是正确的，后面的都是近似值，第二个打印的值是正确的浮点型常量，它是按8字节即double型进行运算的，同时%f会访问寄存器8字节的空间进行浮点运算，因此可以正常输出。</p>
<h2 id="类型强制转换场景">7.5. 类型强制转换场景</h2><p>整型数进行除法运算时，如果运算结果为小数，那么存储浮点数时一定要进行强制类型转换，否则会出现问题，j的值为2，k的值为2.5</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> j=i/<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> k = (<span class="type">float</span>)i/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//j=2.000000 k=2.500000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j=%f k=%f&quot;</span>,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组">7.6. 数组</h2><p>数组，构造数据类型，是指一组具有相同数据类型的数据的有序集合</p>
<h3 id="一维数组格式定义">7.6.1. 一维数组格式定义</h3><p>一维数组定义格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型说明符 数组名[常量];</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>定义了一个整型数组，数组名为a，它有10个元素</p>
<p>声明数组时要遵循以下规则：</p>
<ol>
<li>数组名的命名规则和变量名的相同，即遵循标识符命名规则；</li>
<li>在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式用来表示元素的个数，即数组长度。</li>
<li>常量表达式中可以包含常量和符号常量，但不包含变量，也就是说，C语言不允许对数组的大小做动态定义，即数组的大小不依赖于程序运行过程中变量的值。</li>
</ol>
<p><code>❌错误的声明</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未定义数组大小</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组大小为0没有意义</span></span><br><span class="line"><span class="type">float</span> a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//不能使用原括号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">b</span><span class="params">(<span class="number">2</span>)</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line"><span class="comment">//不能用变量说明数组大小</span></span><br><span class="line"><span class="type">int</span> k=<span class="number">3</span>,a[k];</span><br></pre></td></tr></table></figure>

<h3 id="一维数组在内存中的存储">7.6.2. 一维数组在内存中的存储</h3><p><code>int a[100];</code></p>
<p>定义的一维数组a在内存中存储在一片连续的区域中，每个元素都是整型元素，占用4字节，数组元素的引用方式为 数组名[下标]，即a[i]。</p>
<p>数组元素的下标编号为从0到99，不存在100。</p>
<p><code>定义数组的一瞬间，数组占据的空间大小就确定下来了</code></p>
<h3 id="一维数组的初始化方式">7.6.3. 一维数组的初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义时对数组元素赋初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 赋部分初值</span></span><br><span class="line"><span class="comment">//后6个元素的初值默认为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 全部赋值为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 不指定数组长度下赋值</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字符数组">7.6.4. 字符数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独赋初始值</span></span><br><span class="line">c[<span class="number">0</span>]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">c[<span class="number">1</span>]=<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">c[<span class="number">2</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">c[<span class="number">3</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">c[<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个数组进行初始化</span></span><br><span class="line">c[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>C语言规定字符串的结束标志为<code>\0</code>，所以字符数组存储的字符串长度必须比字符数组少1字节。</p>
<p>使用scanf函数时，<code>scanf(&quot;%s&quot;,c);</code> 字符串末尾自动添加<code>\0</code></p>
<h2 id="指针">7.7. 指针</h2><h3 id="定义">7.7.1. 定义</h3><p>内存区域中的每字节都对应一个编号，这个编号就是“地址”。</p>
<p>如果在程序中定义了一个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元，按变量地址存取变量值的方式称为“直接访问”，如printf(“%d”,i); scanf(“%d”,&amp;i);等；</p>
<p>另一种存取变量值的方式称为“间接访问”，即将变量i的地址存放到另一个变量中，在c语言中，指针变量是一种特殊的变量，它用来存放变量地址。</p>
<p>指针变量定义格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类型 *指针变量名</span></span><br><span class="line"><span class="type">int</span> *i_pointer;</span><br></pre></td></tr></table></figure>

<p>指针与指针变量是两个概念，一个变量的地址称为改该变量的“指针”，例如，地址2000是变量i的指针，如果有一个变量专门用来存放另一个变量的地址(即指针)，那么称它为“指针变量”，例如，<code>i_pointer</code>就是一个指针变量。</p>
<p><code>i_pointer 本身占多大的内存空间？</code></p>
<p>在windows 32位控制台应用程序，寻址范围为32位4字节，即<code>sizeof(i_pointer)=4</code>，如果编写的程序是64位，那么寻址范围就是8字节。</p>
<h3 id="取地址操作符与取值操作符">7.7.2. 取地址操作符与取值操作符</h3><p>取地址操作符为&amp;，也称引用，通过该操作符可以获取一个变量的地址值；</p>
<p>取值操作符为*，也称解引用，通过该操作符可以得到一个地址对应的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> j=<span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> *p;</span><br><span class="line">  p=&amp;i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过&amp;i 获取整型变量i的地址值，然后对整型指针变量p进行初始化，p中存储的是整型变量i的地址值，*p获取的是整型变量i的值，p中存储的是一个绝对地址值。</p>
<p><code>为什么取值时会获取4字节大小的空间呢？</code></p>
<p>因为p为整型变量指针，每个int型数据占用4字节大小的空间，p在解引用时会访问4字节大小的空间，同时以整型值对内存进行解析。</p>
<h3 id="注意点">7.7.3. 注意点</h3><ol>
<li><p><code>int *i_pointer;</code></p>
<p>指针变量前面的<code>*</code>表示改变量为指针变量，指针变量为<code>i_pointer</code>，而不是<code>*i_ponter</code>;</p>
</li>
<li><p>定义指针变量时必须指定类型。只有整型变量的地址才能放到指向整型变量的指针变量中</p>
</li>
<li><p><code>i_pointer=&amp;a;</code></p>
<p>执行该语句后，<code>&amp;*i_pointer</code>的含义是什么？</p>
<p><code>*</code>和<code>&amp;</code>运算符的优先级相同，<code>&amp;*pointer</code>等同于<code>&amp;a</code>，也就是变量a的地址</p>
<p><code>*&amp;a</code>的含义是什么？</p>
<p>首先<code>&amp;a</code>运算得到a的地址，再进行<code>*</code>运算，<code>*&amp;a</code>和<code>*i_pointer</code>的作用一样，都等价于变量a，即<code>*&amp;a</code>等同于a</p>
</li>
<li><p>多个指针变量的声明</p>
<p><code>int *a,*b,*c;</code></p>
<p>而不是<code>int* a,b,c;</code></p>
</li>
</ol>
<h3 id="指针使用场景">7.7.4. 指针使用场景</h3><h4 id="指针的传递">7.7.4.1. 指针的传递</h4><p>通过函数修改变量的值时，形参和变量的地址是不同的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"> 	a=a/<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">  change(i);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入形参a的是值10，而不是i变量的地址值。</p>
<p><code>栈空间的变化</code></p>
<p>当main函数开始执行是，系统会为main函数开辟函数栈空间，</p>
<p>当程序走到int i时，main函数的栈空间就会为变量i分配4字节大小的空间。</p>
<p>调用change函数时，系统会为change函数重新分配新的函数栈空间，并为形参变量a分配4字节大小的空间。</p>
<p>在调用change(i)时，实际上是将i的值赋值给a，这种效果称之为<code>值传递</code>。</p>
<p>因此，当子啊change函数粉函数栈空间内修改变量a的值后，change函数执行结束，其栈空间就会释放，a不复存在，i的值不会改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *a)</span>&#123;</span><br><span class="line"> 	*a = *a/<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">  change(&amp;i);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用仍是值传递，不过此时是将变量i的地址传递给change函数，a是指针变量，内存存储的是变量i的地址，所以通过*a就间接访问到了变量i的值。本身变量a的地址和变量i还是不同的。</p>
<h4 id="指针的偏移">7.7.4.2. 指针的偏移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组名存储着数组的起始地址，其类型为整型指针，赋值给整型变量p。</p>
<p>p+1指向a[1]，因为指针变量+1后，偏移的长度是基类型的长度，也就是偏移sizeof(int)。</p>
<p>编译器在编译时，数组取下标的操作正是转换为指针偏移来完成的。</p>
<h4 id="指针与自增，自减运算符">7.7.4.3. 指针与自增，自减运算符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    <span class="type">int</span> j=*p++;</span><br><span class="line">  	<span class="comment">//a[0]=2 j=2 *p=7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[0]=%d j=%d *p=%d\n&quot;</span>,a[<span class="number">0</span>],j,*p);</span><br><span class="line">    j=p[<span class="number">0</span>]++;</span><br><span class="line">    <span class="comment">//a[0]=2 j=7 *p=8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[0]=%d j=%d *p=%d\n&quot;</span>,a[<span class="number">0</span>],j,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>第一个结果为a[0]=2 j=2 *p=7</code></p>
<p>首先，对于自增运算符一般分为两步，++在后，先进行运算，后进行+1。</p>
<p>此时，j&#x3D;*p，而p指向数组的第一个元素，所以j&#x3D;2。</p>
<p>然后是p++，还是*p++？即指针变量操作还是a[0]操作。答案为指针变量操作，p指向了数组的第二个元素。</p>
<p>因为*操作符和++操作符的优先级相同，只有比++优先级高的操作符才会当成一个整体，目前比++操作符高的只有()和[]操作符。</p>
<p><code>如何让结果为a[0]=3 j=2 *p=3</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j=（*p)++;</span><br></pre></td></tr></table></figure>

<p><code>第二个结果为a[0]=2 j=7 *p=8</code></p>
<p>p指向的是元素a[1]，j&#x3D;p[0]++，忽略++操作符，j&#x3D;a[1]&#x3D;7，接着对p[0]进行++操作，即对a[1]进行++操作，所以*p&#x3D;8.</p>
<h3 id="指针与动态内存申请">7.7.5. 指针与动态内存申请</h3><p>C语言的数组长度必须是固定的。因为定义的整型，浮点型，字符型变量都在栈空间中，而栈空间的大小在编译时是确定的。</p>
<p>如果使用的空间大小不确定，那么就使用堆空间。</p>
<h4 id="malloc函数">7.7.5.1. malloc函数</h4><p>malloc函数用于申请内存</p>
<p>申请空间的单位为<code>字节</code></p>
<p>其格式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>需要给malloc函数传递的参数是一个整型变量，size_t为基本数据类型；</p>
<p>返回值为<code>void*</code>类型的指针，只能用来存储一个地址而不能进行偏移，因为malloc函数并不知道我们申请的空间用来存放什么类型的数据，所以确定要用来存储什么类型的数据后，都会将<code>void*</code>强制类型转换为对应的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;i,&amp;c);</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(i);</span><br><span class="line"></span><br><span class="line">    gets(p);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中，定义的整型变量i，指针变量p均在main函数的栈空间中，通过malloc函数申请的空间会返回一个堆空间的首地址，把首地址存入变量p。</p>
<h4 id="栈空间，堆空间">7.7.5.2. 栈空间，堆空间</h4><p><code>栈</code>是计算机系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈操作，出栈操作都有专门的指令执行，从而栈的效率比较高。</p>
<p><code>堆</code>是C&#x2F;C++函数库提供的数据结构，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间，那么就有可能调用系统功能增加程序数据段的内存空间，从而分到足够大小的内存，然后返回。显然，堆的效率要比栈低得多。</p>
<p>栈空间由系统自动管理，而堆空间的申请和释放需要自行管理，一般通过free函数释放堆空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数栈空间释放后，函数内所有局部变量消失</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">print_stack</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[]=<span class="string">&quot;I am print_stack&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆空间不会因函数执行结束而释放</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">print_malloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;I am print_malloc&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = print_stack();</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line"></span><br><span class="line">    p = print_malloc();</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果中出现乱码，而且每次执行结果不同</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/result.png"><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/result2.png"></p>
<p>原因为print_stack函数中的字符串存放在栈空间中，函数执行结束后，栈空间会被释放，字符数组c的原有空间已被分配给其他函数使用，因此在调用print_stack函数后，执行puts函数就会出现乱码。而print_malloc函数中字符串存放在堆空间中，堆空间只有在执行free操作后才会释放，否则在进程执行过程中会一直有效。</p>
<h4 id="free函数">7.7.5.3. free函数</h4><p>free函数格式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>其传入的参数为void类型指针，任何指针均可自动转为void*类型指针，把p传递给free函数时，不需要强制类型转换，p的地址值必须是malloc当时返回的地址值，不能进行偏移，也就是malloc和free函数之间不能进行p++等改变p的指向。</p>
<p>原因是申请一段堆内存空间时，内核记录的是起始地址和大小，所以释放时内核用对应的首地址进行匹配，匹配不上时，进程就会崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;i,&amp;c);</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(i);</span><br><span class="line"></span><br><span class="line">    gets(p);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">  	<span class="comment">//偏移p</span></span><br><span class="line">    p++;</span><br><span class="line">	  <span class="built_in">free</span>(p);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序崩溃</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/free.png"></p>
<h3 id="字符指针与字符数组">7.7.6. 字符指针与字符数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//把字符串型常量首地址赋值给p</span></span><br><span class="line">  <span class="type">char</span> *p=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="comment">//等价于strcpy(c,&quot;hello&quot;);</span></span><br><span class="line">  <span class="type">char</span> c[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//p[0]=&#x27;H&#x27;;</span></span><br><span class="line">  c[<span class="number">0</span>]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  p=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="comment">//c=&quot;world&quot;;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器在编译时，将字符串型常量存储在数据区中的常量区，这样相同的字符串只会被存储一次，常量区的含义是存储在此区域中的字符串本身<code>不可修改</code>，称之为字符串型常量。</p>
<p>“hello”存储在字符串常量区，占用6字节，首地址赋值给指针变量p。</p>
<p>对于数组变量c，在栈空间有10字节大小的空间，这个初始化将字符串”hello”通过strcpy函数赋值给字符数组c，可以修改c[0]。而p[0]得到的是常量区的空间，不可修改。</p>
<p>p是一个指针变量，它的指向可以修改，重新将”world”字符串的首地址赋值给p，而数组变量c本身存储的是数组首地址，不可修改，c等价于符号常量，c&#x3D;”world”会造成编译不通。</p>
<h3 id="二级指针">7.7.7. 二级指针</h3><p>二级指针也是一种指针，只服务于一级指针的传递与偏移。</p>
<p>整型指针p指向整型变量i，整型指针q指向整型变量j，通过change函数，改变指针变量p的值，指向j。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//想改变变量的值，必须传递变量的地址</span></span><br><span class="line"><span class="comment">//想改变指针变量的值，必须传递指针变量的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> **p ,<span class="type">int</span> *q)</span>&#123;</span><br><span class="line">    *p=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *p=&amp;i;</span><br><span class="line">    <span class="type">int</span> *q=&amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d j=%d p=%d q=%d\n&quot;</span>,i,j,*p,*q);</span><br><span class="line"></span><br><span class="line">    change(&amp;p,q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d j=%d p=%d q=%d\n&quot;</span>,i,j,*p,*q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串操作函数">8. 字符串操作函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> har *str2)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="strlen-统计长度">8.1. strlen 统计长度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">  gets(c);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strcpy-复制数组">8.2. strcpy 复制数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> c1[<span class="number">10</span>];</span><br><span class="line">  gets(c1);</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> c2[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">//c1中的内容复制给c2</span></span><br><span class="line">  <span class="built_in">strcpy</span>(c2,c1);</span><br><span class="line">  <span class="built_in">puts</span>(c2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strcmp-比较大小">8.3. strcmp 比较大小</h2><p>大于，则为正值</p>
<p>小于，则为负值</p>
<p>等于，则为零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> c1[<span class="number">10</span>];</span><br><span class="line">  gets(c1);</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> c2[<span class="number">10</span>];</span><br><span class="line">  gets(c2);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> num = <span class="built_in">strcmp</span>(c1,c2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strcat-连接">8.4. strcat 连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> c1[<span class="number">20</span>];</span><br><span class="line">  gets(c1);</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> c2[<span class="number">10</span>];</span><br><span class="line">  gets(c2);</span><br><span class="line">  <span class="comment">//c2连接到c1后</span></span><br><span class="line">  <span class="built_in">strcat</span>(c1,c2);</span><br><span class="line">  <span class="built_in">puts</span>(c1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用的数据输入和输出">9. 常用的数据输入和输出</h1><p>C语言通过函数库读取标准输入，然后通过对应函数处理将结果打印到屏幕上。输出函数有printf，putchar，puts，而标准的输入函数有scanf，getchar，gets。</p>
<h2 id="scanf函数">9.1. scanf函数</h2><h3 id="介绍">9.1.1. 介绍</h3><p><code>int scanf(const char *format,...);</code></p>
<p>scanf 函数根据由format指定的格式从stdin读取，并保存数据到其他参数。</p>
<p>scanf函数的返回值是<code>成功赋值的变量数量</code>，发生错误时返回EOF(&#x3D;-1)。</p>
<p>C语言未提供输入&#x2F;输出关键字，其输入和输出是通过标准函数库来实现的，C语言通过scanf函数读取键盘输入，键盘输入又被称为标准输入，当scanf函数读取标准输入时，如果还没有输入任何内容，进程会一直处于阻塞状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">//阻塞函数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中，执行输入20，然后回车，显示结果为</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/scanf.png"></p>
<p>第二个scanf函数读取了缓冲区中的<code>\n</code>，打印其实输出了换行，所以不会阻塞。</p>
<h3 id="行缓冲">9.1.2. 行缓冲</h3><p>在这种情况下，当在输入和输出中遇到换行符时，将执行真正的I&#x2F;O操作。这时，输入的字符先存放在缓冲区中，等按下回车键换行时才进行实际的I&#x2F;O操作。典型代表是标准输入缓冲区(stdin)和标准输出缓冲区(stdout)。</p>
<p>示例代码中，标准输入缓冲区中放入的字符为<code>20\n</code>，输入<code>\n</code>后，scanf函数才开始匹配，scanf函数中的%d匹配整型数20，然后放入变量中，接着进行打印输出，这时<code>\n</code>仍然在标准输入函数(stdin)内。</p>
<p>如果第二个scanf函数为<code>scanf(&quot;%d&quot;,&amp;i)</code>，那么依然会发生阻塞，因为scanf函数在读取整型数，浮点数，字符串时，会忽略回车符，空格符等字符。</p>
<p>忽略是指scanf函数执行时会首先删除这些字符，然后再阻塞。scanf函数匹配一个字符时，会在缓冲区删除对应的字符，因为在执行<code>scanf(&quot;%c&quot;,&amp;c)</code>语句时，不会忽略任何字符，所以<code>scanf(&quot;%c&quot;,&amp;c)</code>读取了还在缓冲区中残留的<code>\n</code>。</p>
<h3 id="具体代码格式">9.1.3. 具体代码格式</h3><table>
<thead>
<tr>
<th>代码</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符<br>char c;<br>scanf(“%c”,&amp;c);</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数<br>int i;<br>scanf(“%d”,&amp;i);</td>
</tr>
<tr>
<td>%f，%e，%g</td>
<td>浮点数<br>float f;<br>scanf(“%f”,&amp;f);</td>
</tr>
<tr>
<td>%lf</td>
<td>双精度浮点数<br>double d;<br>scanf(“%lf”,&amp;d);</td>
</tr>
<tr>
<td>%s</td>
<td>字符串<br> char str[];<br> scanf(“%s”,str);</td>
</tr>
</tbody></table>
<h3 id="循环读取">9.1.4. 循环读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)!=EOF)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输入a - 出现循环输出问题？</code></p>
<p>当输入的是整数10时，缓冲区中有 <code>10\n</code>,匹配10给变量后，再次输入整数时，缓冲区会删除残留的<code>\n</code>。</p>
<p>当输入的不是整数，而是字符时，scanf的返回值是成功赋值的变量数量，即此时为0，而EOF的值是-1，判断 0!&#x3D;-1，为true，while循环一直匹配，从而出现死循环。</p>
<p>Mac结束循环 <code>control+d</code></p>
<h2 id="printf函数">9.2. printf函数</h2><p>printf函数可以输出各种类型的数据，包括整型，浮点型，字符型，字符串等，实际原理是printf函数将这些类型的数据格式化为字符串后，放入标准输出缓冲区，然后通过<code>\n</code>来刷新标准输出，并将结果显示到屏幕中。</p>
<p>语法格式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br></pre></td></tr></table></figure>

<p>根据format给出的格式打印输出到stdout(标准输出)和其他参数中。</p>
<p>字符串格式(format)由两部分组成：显示到屏幕上的字符和定义printf函数显示的其他参数，指定一个包含文本在内的format字符串，也可以是映射到printf的其他参数“特殊”字符，如下列代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s, you are %d years old\n&quot;</span>,<span class="string">&quot;Bob&quot;</span>,age);</span><br></pre></td></tr></table></figure>

<p>printf函数的具体代码格式：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%d</td>
<td>带符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%u</td>
<td>无符号整数</td>
</tr>
<tr>
<td>%x</td>
<td>无符号十六进制数，用小写字母</td>
</tr>
<tr>
<td>%X</td>
<td>无符号十六进制数，用大写字母</td>
</tr>
<tr>
<td>%p</td>
<td>指针</td>
</tr>
<tr>
<td>%%</td>
<td>%符号</td>
</tr>
</tbody></table>
<p>位于%和格式化命令之间的一个整数被称为最小字段宽度说明符，通常会加上足够多的空格或0使输出足够长，如果填充0，那么就在最小字段宽度说明符前面放置0，另外，也可以使用一个精度修饰符，精度修饰符根据使用的格式代码的不同通常有着不同的含义：</p>
<ul>
<li>%f 精度修饰符指定想要的小数位数，例如，%5.2f会至少显示5位数字并带有2位小数的浮点数。</li>
<li>%s 精度修饰符简单表示一个最大的长度，以补充句点前的最小字段长度。例如，%10s代表字符串共占用10个字符的位置，printf函数默认为右对齐。</li>
<li>%d 精度修饰符指定输出的整型样式，例如，可以规定整型高位用0填充。<code>%05d</code>，显示5位数字，不足5位的整型左高位用0填充，超过5位的整型不受影响。</li>
<li>printf函数的所有输出都是右对齐的，除非在%符号后放置了负号，例如，%-5.2f 会显示5位字符，2位小数位的浮点数并且左对齐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">96.3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%3d f=%5.2f\n&quot;</span>,i,f);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%-3d f=%-5.2f\n&quot;</span>,i,f);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%03d f=%5.2f\n&quot;</span>,i,f);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为整型数载不加符号时靠右对齐，加负号时靠左对齐，整型数加0显示，字符串相对于左边的起始位置右5个空格位置。</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/printf.png"></p>
<h2 id="getchar函数">9.3. getchar函数</h2><p>getchar函数可以一次从标准输入读取一个字符，等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br></pre></td></tr></table></figure>

<p>其中getchar函数每次只能读取一个字符，语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  c = getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c=%c&quot;</span>,c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="putchar函数">9.4. putchar函数</h2><p>putchar函数是向显示设备输出一个字符，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br></pre></td></tr></table></figure>

<p>参数ch是要输出的字符，它既可以是字符型变量，整型变量，又可以是常量，输出字符H的代码为<code>putchar(&#39;H&#39;)。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  c = getchar();</span><br><span class="line">  <span class="built_in">putchar</span>(c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gets函数">9.5. gets函数</h2><p>gets函数类似于scanf函数，用于读取标准输入。</p>
<p>scanf函数在读取字符串时遇到空格就认为读取结束，所以当输入的字符串中存在空格时，可以使用gets函数进行读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">gets(c);</span><br></pre></td></tr></table></figure>

<h2 id="fgets函数">9.6. fgets函数</h2><p>不能使用gets函数时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">fgets(str,<span class="keyword">sizeof</span>(str),<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<h2 id="puts函数">9.7. puts函数</h2><p>gets函数的格式为<code>int put(char *str);</code></p>
<p>把str字符串写入标准输入，puts执行成功时返回非负值，执行失败时返回EOF。</p>
<p>puts函数会将数组c中存储的字符串打印到屏幕上，同时打印换行，相对于printf函数，puts函数只能用于输出字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">gets(c);</span><br><span class="line"><span class="built_in">puts</span>(c);</span><br></pre></td></tr></table></figure>

<h1 id="运算符与表达式">10. 运算符与表达式</h1><h2 id="运算符分类">10.1. 运算符分类</h2><p>C语言提供了13中类型的运算符：</p>
<ol>
<li>算术运算符(<code>+ - * / %</code>)</li>
<li>关系运算符(<code>&gt; &lt; == &gt;= &lt;= !=</code>)</li>
<li>逻辑运算符(<code>! &amp;&amp; ||</code>)</li>
<li>位运算符(<code>&lt;&lt; &gt;&gt; ~ | ^ &amp;</code>)</li>
<li>赋值运算符(<code>=</code>)</li>
<li>条件运算符(<code>?:</code>)</li>
<li>逗号运算符(<code>,</code>)</li>
<li>指针运算符(<code>* &amp;</code>)</li>
<li>求字节数运算符(<code>sizeof</code>)</li>
<li>强制类型转换运算符(<code>(类型)</code>)</li>
<li>分量运算符(<code>. -&gt;</code>)</li>
<li>下标运算符(<code>[]</code>)</li>
<li>其他(<code>如函数调用运算符()</code>)</li>
</ol>
<h2 id="C语言符号优先级">10.2. C语言符号优先级</h2><p>同一优先级的运算符，运算次序由结合方向所决定。</p>
<p>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>
<p><code>此外运算符还有“目”和“结合性”的概念</code></p>
<p>“目”就是“眼睛”的意思，一个运算符需要几个数就叫“几目”。比如加法运算符<code>+</code>，要使用这个运算符需要两个数，如 3+2。对<code>+</code>而言，3 和 2 就像它的两只眼睛，所以这个运算符是双目的。C语言中大多数的运算符都是双目的，也有单目和三目的。单目运算符比如逻辑非，如<code>!1</code>，它就只有一只眼睛，所以是单目的。整个C语言中只有一个三目运算符，即条件运算符<code>? :</code>。</p>
<p>那么“结合性”是什么呢？上面讲的优先级都是关于优先级不同的运算符参与运算时先计算谁后计算谁。但是如果运算符的优先级相同，那么先计算谁后计算谁呢？这个就是由“结合性”决定的。</p>
<p>比如<code>1+2×3÷4</code>，乘和除的优先级相同，但是计算的时候是从左往右，即先计算乘再计算除，所以乘和除的结合性就是从左往右。</p>
<p>C语言中大多数运算符的结合性都是从左往右，只有三个运算符是从右往左的。一个是单目运算符，另一个是三目运算符，还有一个就是双目运算符中的赋值运算符<code>=</code>。双目运算符中只有赋值运算符的结合性是从右往左的，其他的都是从左往右。</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/priority.png"></p>
<h2 id="算术运算符及算数表达式">10.3. 算术运算符及算数表达式</h2><p>算术运算符包含+，-，*，&#x2F;和%，当一个表达式中同时出现这5种运算符时，先进行乘，除，取余，后进行加，减，也就是乘，除，取余运算符的优先级高于加，减运算符。</p>
<p>除%运算符外，其余几种运算符既适用于浮点数又适用于整型数。</p>
<p>当操作符的两个操作数都是整型数时，它执行整除运算，在其他情况下执行浮点型数除法。</p>
<p>%为取模运算符，它接收两个整型操作数，将左操作数除以右操作数，但它的返回值是余数而不是商。</p>
<h2 id="关系运算符及关系表达式">10.4. 关系运算符及关系表达式</h2><p>关系运算符&gt;，&lt;，&#x3D;&#x3D;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;依次为大于，小于，等于，小于等于，大于等于，是否等于。</p>
<p>由关系运算符组成的表达式称为关系表达式，关系表达式的值只有真或假，对应的值为1或0。</p>
<p>由于C语言中没有布尔类型，所以在C语言中0值代表假，非0值即为真，例如，关系表示式3&gt;4为假，因此整体值为0，而关系表达式5&gt;2为真，因此整体值为1。</p>
<p>关系运算符的优先级低于算术运算符。</p>
<p>判断三个数是否相等时，不可以写为<code>if(5==5==5) </code>，因为首先5&#x3D;&#x3D;5得到的结果为1，然后1&#x3D;&#x3D;5得到的结果为0。判断三个变量a，b，c是否相等，应该写为<code>a==b&amp;&amp;b==c</code></p>
<p>判断变量是否位于一段值之间时，不能写为<code>3&lt;a&lt;10</code>，无论a是大于3还是小于3，对于3&lt;a这个表达式只有1或0两种结果。由于1和0都是小于10的，所以无论a的值是什么，这个表达式的值始终为真，因此在判断变量a是否大于3且同时小于10时，要写成<code>a&gt;3&amp;&amp;a&lt;10</code></p>
<p><code>浮点数是否等于某个值的方法</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">234.56</span>;</span><br><span class="line">  <span class="keyword">if</span>(f<span class="number">-234.56</span>&gt;<span class="number">-0.0001</span> &amp;&amp; f<span class="number">-234.56</span>&lt;<span class="number">0.0001</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f等于234.56&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f等于234.56&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为关系元素付的优先级低，所以f-234.56不用加括号，浮点数中存储的是对应数的近似值，只能保证精度为7位。</p>
<h2 id="逻辑运算符与逻辑表达式">10.5. 逻辑运算符与逻辑表达式</h2><p>逻辑运算符!，&amp;&amp;，|| 依次为逻辑非，逻辑与，逻辑或，这和数学上的与，或，非是一致的。</p>
<p>逻辑非的优先级高于算术运算符，逻辑与和逻辑或的优先级低于关系运算符。</p>
<p>逻辑表达式的值只有真或假，对应的值为1或0。</p>
<h2 id="位运算符">10.6. 位运算符</h2><p>位运算符 <code>&lt;&lt; , &gt;&gt; , ~，|，^，&amp;</code> 依次是左移，右移，按位取反，按位或，按位异或，按位与。</p>
<p><code>左移&lt;&lt;</code>：高位丢弃，底位补0，相当于乘以2，多用于申请内存时。例如要申请1GB大小的空间，可以使用malloc(1&lt;&lt;30)。</p>
<p><code>右移&gt;&gt;</code>：底位丢弃，正数的高位补0，无符号数认为是正数，负数的高位补1，相当于除以2，移位比乘法和除法的效率要高，负数右移，对偶数来说是除以2，但对奇数来说是先减1后除以2。例如-8&gt;&gt;1&#x3D;-4，-7&gt;&gt;1&#x3D;-4。另外，对于-1来说，无论右移多少位，值永远为-1。</p>
<p><code>异或^</code>：相同的数进行异或时，结果为0，任何数和0异或的结果是其本身。</p>
<p><code>按位取反~</code>：数位上的数是1变为0，0变为1。</p>
<p><code>按位与&amp;和按位或|</code>：用两个数的每一位进行与和或。</p>
<h3 id="异或-交换变量值">10.6.1. 异或-交换变量值</h3><p><code>通过异或操作交换两个变量</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure>



<h3 id="与-最低位为1的整数">10.6.2. 与-最低位为1的整数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> result = a &amp; -a；</span><br></pre></td></tr></table></figure>



<h2 id="赋值运算符">10.7. 赋值运算符</h2><p>左值是那些能够出现在赋值符号左边的东西，右值是那些可以出现在赋值符号右边的东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<p>其中，a是一个左值，因为它标识了一个可以存储结果值的地点；b+25是一个右值，因为它指定了一个值。</p>
<p><code>它们可以互换吗？</code></p>
<p>因为每个位置都包含一个值，所以原先用作左值的a此时可以作为右值，然而，b+25 不能作为左值，因为它并未标识一个特定的位置，并不对应特定的内存空间，因此，这条赋值语句不能互换。</p>
<p>赋值运算符的优先级是非常低的，仅高于逗号运算符。</p>
<h2 id="复合赋值运算符">10.8. 复合赋值运算符</h2><p>复合赋值运算符操作是一种缩写形式，使用复合赋值运算符能使对变量的赋值操作变得更加简洁，同时简化了程序，提高了编译效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//a=a+4;</span></span><br><span class="line">a+=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符与逗号运算符">10.9. 条件运算符与逗号运算符</h2><p>条件运算符时C语言中唯一的一种三目运算符，三目运算符代表右三个操作数；双目运算符代表右两个操作数，如逻辑与运算符就是双目运算符；单目运算符代表右一个操作数，如逻辑非运算符就是单目运算符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(a&gt;<span class="number">10</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="comment">//===等价于==</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过三目运算符一定程度上简化了很多if判断代码。</p>
<p>运算符也称为操作符，逗号运算符的优先级最低。</p>
<h2 id="自增，自减运算符">10.10. 自增，自减运算符</h2><p>自增，自减运算符和其他运算符有很大的区别，因为其他运算符除赋值运算符可以改变变量本身的值外，不会有这种效果，自增，自减就是对变量进行加1，减1操作。</p>
<p>那么有了加法和减法运算符为什么还要发明这种运算符呢？</p>
<p>原因是自增和自减来源于B语言，当时Ken Thompson和Dennis M.Ritchie为了不改变程序员的编写习惯，在C语言中保留了B语言中的自增和自减，因为自增，自减会改变变量的值，所以自增和自减不能用于常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> a = i++;</span><br><span class="line">  <span class="type">int</span> b = ++j;</span><br><span class="line">  <span class="comment">//i=1 j=1 a=0 b=1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i=%d j=%d a=%d b=%d\n&quot;</span>,i,j,a,b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出显示，自增中，++在前进行的是先赋值后+1，++在后进行的是先+1后赋值</p>
<h1 id="选择结构程序设计">11. 选择结构程序设计</h1><h2 id="关系表达式与逻辑表达式">11.1. 关系表达式与逻辑表达式</h2><p>算术运算符(+,-,*,&#x2F;)的优先级高于关系运算符(&lt;,&gt;,&lt;&#x3D;,&gt;&#x3D;,&#x3D;&#x3D;,!&#x3D;)</p>
<p>关系运算符优先级高于逻辑与和逻辑或运算符</p>
<p>相同优先级的运算符从左到右进行结合</p>
<p><code>闰年判断</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;闰年&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="if语句">11.2. if语句</h2><p>if判断为真就执行某些语句，反之不执行这个语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if语句也支持多层嵌套</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言中的else字据从属于最靠近它的不完整的if语句。</p>
<h2 id="switch语句">11.3. switch语句</h2><p>判断的一个变量可以等于几个值或几十个值时，使用if和else if语句会导致else if分支非常多，这时可以考虑使用switch语句，语法格式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">    语句n</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入一个年份和月份，然后打印对应月份的天数，如输入一个闰年和2月，则输出为29天</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> mon,year;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;year,&amp;mon)!=EOF)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(mon)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is %d days\n&quot;</span>,mon,<span class="number">28</span>+(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 30 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 30 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 30 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 30 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error mon\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句中case后面的常量表达式的值不是按照1到12的顺序排列的，但不影响结果。因为switch语句匹配并不需要常量表达式的值有序排列，输入值等于哪个常量表达式的值，就执行其后的语句，每条语句后需要加上break语句，代表匹配成功一个常量表达式时就不再匹配并跳出switch语句。</p>
<p>改进</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> mon,year;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;year,&amp;mon)!=EOF)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(mon)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is %d days\n&quot;</span>,mon,<span class="number">28</span>+(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 31 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mon=%d is 30 days\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error mon\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个case语句后面没有break语句，那么程序会继续匹配下面的case常量表达式。</p>
<p>原理是只要匹配到1,3,5,7,8,10,12中的任何一个，就不再拿mon与case后的常量表达式的值进行比较，而执行输出语句完毕后执行break语句跳出switch语句。switch与最后加入default的目的是，在所有case后的常量表达式的值都未匹配时，打印输出错误标志或者一些提醒，以便快速掌握代码的执行情况。</p>
<h1 id="循环结构程序设计">12. 循环结构程序设计</h1><h2 id="while循环">12.1. while循环</h2><p>用来实现“当型”循环结构，形式为<code>while(表达式)</code>，当表达式的值非0时，执行while语句中的内嵌语句。其特点是：先判断表达式，后执行语句。当表达式的值非0时，就会执行语句，从而实现语句多次执行的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1到100之间所有整数之和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="do-x2F-while循环">12.2. do&#x2F;while循环</h2><p>do&#x2F;while 语句的特点是：先执行循环体，后判断循环条件是否成立。其一般形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>首先执行一次指定的循环体语句，然后判断表达式，当表达式的值为非零时，返回重新执行循环体语句，如此反复，直到表达式的值等于0为止。</p>
<p>计算1到100之间的所有整数之和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">     total+=i;</span><br><span class="line">     i++;</span><br><span class="line">  &#125; <span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do&#x2F;while语句与while语句的差别是，do&#x2F;while语句第一次执行循环体语句之前不会判断表达式的值，也就是如果i的初值为101，那么依然会进入循环体。</p>
<h2 id="for循环">12.3. for循环</h2><p>C语言中的for循环完全可以代替while循环语句，形式为<code>for(表达式1;表达式2;表达式3)</code></p>
<p>流程为：</p>
<ol>
<li>计算表达式1</li>
<li>判断表达式2。一般表达式2为一个判断句，若其值为0，则退出整个for循环；若其值为1，则执行for语句中的内嵌语句后，执行表达式3</li>
<li>转回步骤2继续执行，直到表达式2不满足后，退出for循环。</li>
</ol>
<p>同样求1到100之间整数之和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> sum =<span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="continue">12.4. continue</h2><p>该关键字的作用是跳过循环体中尚未执行的语句。</p>
<p>若计算1到100之间所有奇数之和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//i为偶数时跳过本次循环</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    sum+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="break">12.5. break</h2><p>break的作用时结束整个循环过程，不再判断执行循环的条件是否成立。</p>
<p>当累加和大于2000时，结束for循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;<span class="number">2000</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    sum+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数">13. 函数</h1><p>一个C程序可以由一个主函数和若干个其他函数构成。</p>
<p>函数间的调用关系是，由主函数调用其他函数，其他函数也可以互相调用，同一个函数可以被一个或多个函数调用任意次。</p>
<h2 id="示例">13.1. 示例</h2><p>func.h，func.c，main.c三个文件放在同一个文件夹下</p>
<p>func.h中存放的是标准头文件的声明和main函数中调用的两个子函数的声明，如果不在头文件中对使用的函数进行声明，那么在编译时会出现警告。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件-func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printstar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>func.c是子函数printstar和print_message的实现，也称为定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printstar</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print star %d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;how do you do\n&quot;</span>);</span><br><span class="line">    printstar(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c是main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a= <span class="number">10</span>;</span><br><span class="line">    a = printstar(a);</span><br><span class="line">    print_message();</span><br><span class="line">    printstar(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c func.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/func.png"></p>
<h2 id="C语言的编译和执行特点">13.2. C语言的编译和执行特点</h2><ol>
<li>一个C程序由一个或多个程序模块组成，每个程序模块作为一个源程序文件。对于较大的程序，通常将程序内容分别放在若干源文件中，再由若干源程序组成一个C程序。这样处理便于编写，分别编译，进而提高调试效率。一个源程序文件可以为多个C程序共用。</li>
<li>一个源程序文件由一个或多个函数及其他内容(如命令行，数据定义等)组成。一个源程序文件是一个编译单位，在程序编译时是以源程序文件为单位而不是以函数为单位进行编译的。main.c和func.c分别单独编译，在链接成为可执行文件时，main中调用的函数printstar和print_message才会通过链接去找到函数定义的位置。</li>
<li>C程序的执行是从main函数开始的，如果在main函数中调用其他函数，那么在调用后会返回main函数中，在main函数中结束整个程序运行。</li>
<li>所有函数都是平行的，即在定义函数时是分别进行的，并且是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。函数间可以互相调用，但不能调用main函数。main函数是由系统调用的，如main函数中调用print_message函数，而print_message函数中又调用printstar函数，这种调用称为嵌套调用。</li>
</ol>
<h2 id="函数的声明与定义的差异">13.3. 函数的声明与定义的差异</h2><ol>
<li>函数的定义是指对函数功能的确立，包含指定函数名，函数值类型，形参及其类型，函数体等，它是一个完整的，独立的函数单位。</li>
<li>函数的声明的作用是把函数的名字，函数类型及其形参的类型，个数和顺序通知编译系统，以便在调用该函数时编译系统能正确识别函数并检查调用是否合法。</li>
<li>隐式声明是指C语言中有几种声明的类型名可以省略。例如，函数如果不显式地声明返回值的类型，那么它默认返回整型；使用旧风格声明函数的形式参数时，如果省略参数的类型，那么编译器默认它们为整型。然而，依赖隐式声明并不是好的习惯，因为隐式声明容易让代码的读者产生疑问；编写者是否有意遗漏了类型名？还是不小心忘记了？显式声明能够清楚滴表达意图。</li>
</ol>
<h2 id="函数的分类与调用">13.4. 函数的分类与调用</h2><p><code>从用户角度来看，函数分为两种</code>：</p>
<ol>
<li>标准函数。即库函数，这是由系统提供的，用户不必自己定义的函数，可以直接使用。如，printf函数，scanf函数。不同的C系统提供的库函数的数量和功能会有一些不同，但许多基本的函数是相同的。</li>
<li>用户自己定义的函数，用以解决用户的专门需要。</li>
</ol>
<p><code>从函数的形式看，函数分为如下两类</code>：</p>
<ol>
<li><p>无参函数。一般用来执行指定的一组操作。在调用无参函数时，主调函数不向被调用函数传递数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 函数名()&#123;</span><br><span class="line">  声明部分</span><br><span class="line">  语句部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参函数。主调函数在调用被调用函数时，通过参数向被调用函数传递数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 函数名(形式参数表列)&#123;</span><br><span class="line">  声明部分</span><br><span class="line">  语句部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>printstar函数就是有参函数，int i对应的i为形式参数，主调函数和被调用函数之间存在数据传递关系。</p>
<p>在不同的函数之间传递数据时，可以使用的方法如下：</p>
<ol>
<li>参数：通过形式参数和实际参数</li>
<li>返回值：用return语句返回计算结果</li>
<li>全局变量：外部变量</li>
</ol>
<h2 id="全局变量">13.5. 全局变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main i=%d\n&quot;</span>,i);</span><br><span class="line">    i=<span class="number">5</span>;</span><br><span class="line">    print(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/all.png"></p>
<h3 id="全局变量存储在哪里">13.5.1. 全局变量存储在哪里</h3><p>存储在数据段，所以main函数和print函数都是可见的。全局变量不会因为某个函数执行结束而消失，在整个进程的执行过程中始终有效，因此工作中应尽量避免使用全局变量。</p>
<p>局部变量存储在自己的函数对应的栈空间内，函数执行结束后，函数内的局部变量所分配的空间将会得到释放。如果拒不变量与全局变量重名，那么将采取就近原则，即实际获取和修改的值是局部变量的值。</p>
<h3 id="形参和实参">13.5.2. 形参和实参</h3><p>如果把print(int a)改为print(int i)，那么print函数的打印结果会是什么？<code>不变</code></p>
<ol>
<li>定义函数中指定的形参，如果没有函数调用，那么它们并不占用内存中的存储单元，只有在发生函数调用是，函数print中的形参才被分配内存单元，在调用结束后，形参所站的内存单元也会释放。</li>
<li>实参可以是常量，变量或是表达式，但要求它们有确定的值，如，print(i+3)在调用时将实参的值赋给形参。假如print函数有两个形参，如print(int a,int b)，那么实际调用print函数时，使用print(i,i++)是不合适的，因为C标准未规定函数调用是从左到右计算还是从右到左计算，因此不同的编译会有不同的标准，造成代码在移植过程中发生非预期错误。</li>
<li>在被定义的函数中，必须指定形参的类型，如果实参列表中包含多个实参，那么各参数间用逗号隔开，实参与形参的个数应相等，类型应匹配，且实参与形参应顺序对应，一一传递数据。</li>
<li>实参与形参的类型应相同或赋值应兼容。</li>
<li>实参向形参的数据传递是单向值传递，只能由实参传给形参，而形参无法传回给实参。在调用函数时，给形参分配存储单元，并将实参对应的值传递给形参，调用结束后，形参单元被释放，实参单元仍保留并维持原值。</li>
</ol>
<h2 id="变量及函数的作用域">13.6. 变量及函数的作用域</h2><h3 id="局部变量">13.6.1. 局部变量</h3><p>在函数内部定义的变量称为内部变量，它只在本函数范围内有效，即只有在本函数内才能使用这些变量，故也称局部变量。</p>
<p>📢注意点：</p>
<ol>
<li><p>主函数中定义的变量只在主函数中有效，而不因为在主函数中定义而在整个文件或程序中有效。主函数也不能使用其他函数中定义的变量。</p>
</li>
<li><p>不同函数中可以使用相同名字的变量，它们代表不同的对象，互不干扰。</p>
</li>
<li><p>形式参数也是局部变量。</p>
</li>
<li><p>在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序’’或”程序块“。即只在离自己最近的花括号内有效，若离开花括号，则在其下面使</p>
<p>用该变量会造成编译不通。</p>
</li>
</ol>
<h3 id="外部变量">13.6.2. 外部变量</h3><p>函数之外定义的变量称为外部变量。外部变量可以为本文件中的其他函数共用，它的有效范围是从定义变量的位置开始到本源文件结束，所以也称全程变量。</p>
<p>📢注意点：</p>
<ol>
<li>全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。</li>
<li>使用全局变量过多会降低程序的清晰性。在各个函数执行是都可能改变外部变量的值，程序容易出错，因此要有限制地使用全局变量。</li>
<li>因为函数在执行时依赖于其所在的外部变量，如果将一个函数移到另一个文件中，那么还要将有关的外部变量及其值一起移过去。然而，如果该外部变量与其他文件的变量同名，那么就会出现问题，即会降低程序的可靠性和通用性。C语言一般要求把程序中的函数做成一个封闭体，除可以通过实参-&gt;形参的渠道与外界发生联系外，没有其他渠道。</li>
</ol>
<h1 id="结构体">14. 结构体</h1><p>C语言提供结构体来管理不同类型的数据组合。</p>
<h2 id="结构体的定义">14.1. 结构体的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct 结构体名&#123;</span></span><br><span class="line"><span class="comment">  成员表列</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构体声明</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结构体所占用的是68个字节，</span></span><br><span class="line"><span class="comment">因为存在对齐，</span></span><br><span class="line"><span class="comment">提高CPU访问内存的效率，</span></span><br><span class="line"><span class="comment">降低单个数据需要分多次多行获取的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">  <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//变量定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">3</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[<span class="title">num</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span>=</span>&#123;<span class="number">1001</span>,<span class="string">&quot;lele&quot;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">20</span>,<span class="number">98</span>,<span class="string">&quot;Shenzhen&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c %d %f %s\n&quot;</span>,stu2.num,stu2.name,stu2.sex,stu2.age,stu2.score,stu2.addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %c %d %f %s&quot;</span>,&amp;stu[i].num,stu[i].name,&amp;stu[i].sex,&amp;stu[i].age,&amp;stu[i].score,stu[i].addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student %d: %d %s %c %d %f %s\n&quot;</span>,i,stu[i].num,stu[i].name,stu[i].sex,stu[i].age,stu[i].score,stu[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体类型声明要放在main函数之前，这样main函数中才可以使用这个结构体，一般往往把结构体声明放在头文件中。📢注意，结构体类型声明最后一定要加分号，否则会编译不通。</p>
<p>另外，定义结构体变量时，使用<code>struct student</code>来定义，不能只有struct或student，否则也会编译不通，stu是结构体数组变量。</p>
<p>结构体的初始化只能在一开始定义，如果<code> struct student stu2=&#123;1001,&quot;lele&quot;,&#39;M&#39;,20,98,&quot;Shenzhen&quot;&#125;;</code>分为两步：<code> struct student stu2;</code> 和 <code>stu2=&#123;1001,&quot;lele&quot;,&#39;M&#39;,20,98,&quot;Shenzhen&quot;&#125;;</code> 将编译不通。此时只能对它的每个成员单独赋值，如<code>stu.num=1003</code>。</p>
<p>采用”结构体变量名.成员名“的形式来访问结构体成员，例如用stu.num访问学号。在进行打印输出时，必须访问到成员，而且printf的%类型要与各成员匹配。使用scanf读取标准输入时，也必须是各成员取地址，然后进行存储，不可以写成%s，即不可以直接对结构体变量取地址。</p>
<p>整型数据(%d)，浮点型数据(%f)，字符串性数据(%s)都会忽略空格，但是字符型数据(%c)不会忽略空格，所以如果要读取字符型数据，那么就要在待读取的字符数据与其他数据之间加入空格。</p>
<h2 id="结构体指针">14.2. 结构体指针</h2><p>一个结构体变量的指针就是该变量所占据的内存段的起始地址。</p>
<p>可以设置一个指针变量，用它指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址。</p>
<p>指针变量也可以用来指向结构体数组中的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构体声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span>=</span>&#123;<span class="number">1001</span>,<span class="string">&quot;lele&quot;</span>,<span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,stu2.num,stu2.name,stu2.sex);</span><br><span class="line">  </span><br><span class="line">		<span class="comment">//定义结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">stu</span>;</span></span><br><span class="line">    stu=&amp;stu2;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//获取成员方式一： stu-&gt;name</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stu-&gt;name, <span class="string">&quot;Wang&quot;</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//获取成员方式二： (*stu).num</span></span><br><span class="line">    (*stu).num = <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;student %d: %s %c\n&quot;</span>,stu-&gt;num,stu-&gt;name,stu-&gt;sex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/struct.png"></p>
<p>stu就是一个结构体指针，可以对结构student取地址并赋给stu，这样借助成员选择操作符，就可以通过stu访问结构体的每个成员，然后进行打印。</p>
<p>获取成员的方式一种使用<code>(*stu).num</code> ，加括号是因为<code>.</code>的优先级高于<code>*</code></p>
<h1 id="typedef">15. typedef</h1><p>typedef声明新的类型名来代替已有的类型名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构体声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">&#125;stu,*pstu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    stu s=&#123;<span class="number">1001</span>,<span class="string">&quot;lele&quot;</span>,<span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,s.num,s.name,s.sex);</span><br><span class="line"></span><br><span class="line">    INTEGER i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    pstu p = &amp;s;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;Wang&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;student %d: %s %c\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用stu定义结构体变量和使用struct student定义结构体变量是等价的</p>
<p>使用INTEGER定义变量i和使用int 定义变量i是等价的</p>
<p>pstu等价于struct student *，所以p是结构体指针变量</p>
<h1 id="C-的引用">16. C++的引用</h1><p>变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> <span class="title function_">modifynum</span><span class="params">(<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">  b++;</span><br><span class="line">&#125;</span><br><span class="line">modifynum(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========等价于C语言===============</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> <span class="title function_">modifynum</span><span class="params">(<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">  (*b)++;</span><br><span class="line">&#125;</span><br><span class="line">modifynum(&amp;a);</span><br></pre></td></tr></table></figure>

<p>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">modifynum</span><span class="params">(<span class="type">int</span> *&amp;q)</span>&#123;</span><br><span class="line">  q=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">  q[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">modifynum(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========等价于C语言===============</span></span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">modifynum</span><span class="params">(<span class="type">int</span> **q)</span>&#123;</span><br><span class="line">  *q=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">  q[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">modifynum(&amp;p);</span><br></pre></td></tr></table></figure>



<h1 id="const">17. const</h1><p><code>const int i</code>类型一旦定义，就不能修改，而int类型可以随时修改，因为const int是用来保存一些全局常量的，因此这些常量在编译期间可以修改，但在运行期间不能修改。</p>
<p>听起来这很像宏，其实她确实是用来取代宏的。例如，比较 <code>#define PI 3</code>和 <code>const int Pi=3</code>;如果代码中用到了100次PI(宏)，那么代码中就会保存100个常数3。</p>
<p>由于使用常数进行运算的机器代码很多时候要比使用变量时的机器代码长，因此换用100次Pi(const int)后，程序编译后的机器码中就不需要出现100次常量3，而只在需要时引用存储有3的常量。</p>
<p>从汇编的角度看，const定义的常量只给出了对应的内存地址，而不像#define那样给出的是立即数，所以const定义的常量在程序运行过程中只有一份副本，而#define定义的常量在内存中有若干副本，编译器通常不为普通的const常量分配存储空间，而将它们保存在符号表中，这就使得它成为一个编译期间的常量，而没有存储与读内存的操作，因此使得它的效率也很高。</p>
<h2 id="const-char-ptr">17.1. const char *ptr;</h2><p>定义一个指向字符常量的指针，其中ptr是一个指向<code>char*</code>类型的常量，不能用ptr来修改所指向的内容，换句话说，<code>*ptr</code>的值为const，不能修改，但是ptr的声明并不意味着它指向的值实际上就是一个常量，而只意味着对ptr而言，这个值是常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = str;</span><br><span class="line">  str[<span class="number">0</span>]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">  <span class="comment">// Hello world</span></span><br><span class="line">  <span class="built_in">puts</span>(ptr);</span><br><span class="line">  <span class="comment">// read-only variable is not assignable</span></span><br><span class="line">  <span class="comment">// ptr[0]=&#x27;n&#x27;;</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> str1[]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  p=str1;</span><br><span class="line">  <span class="comment">// Hello</span></span><br><span class="line">  <span class="built_in">puts</span>(p);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ptr指向str，而str不是const，可以直接通过str变量来修改str[0]的值，但不能通过ptr指针来修改</p>
<blockquote>
<p>char const *ptr 与 const char *ptr等价，通常使用const char *ptr</p>
</blockquote>
<h2 id="char-const-ptr">17.2. char * const ptr;</h2><p>定义一个指向字符的指针常量，即const指针，不能修改ptr指针，但可以修改该指针指向的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="type">char</span> str1[]=<span class="string">&quot;how do you do&quot;</span>;</span><br><span class="line">  <span class="type">char</span> * <span class="type">const</span> ptr = str;</span><br><span class="line">  str[<span class="number">0</span>]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">  <span class="built_in">puts</span>(ptr);</span><br><span class="line">  ptr[<span class="number">0</span>]=<span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">  <span class="built_in">puts</span>(ptr);</span><br><span class="line">  <span class="comment">// variable &#x27;ptr&#x27; declared const here</span></span><br><span class="line">  <span class="comment">// ptr=str1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const 直接修饰指针时，指针ptr指向的内容可以修改，但是指针ptr在第一次初始化后，后面不能再对ptr进行赋值，否则会出现编译报错。</p>
<h1 id="文件操作">18. 文件操作</h1><p>程序执行时就称为进程，进程运行过程中的数据均在内存中。需要存储运算后的数据时，就需要使用文件。</p>
<h2 id="C文件概述">18.1. C文件概述</h2><p>文件是指存储在外部介质（如磁盘，磁带）上的数据集合。操作系统（Windows，Linux，Mac等）是以文件为单位对数据进行管理的。</p>
<p><img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/file.png"></p>
<p>C语言对文件的处理方法如下：</p>
<ul>
<li><code>缓冲文件系统</code>：系统自动地在内存区为每个正在使用的文件开辟一个缓冲区，用缓冲文件系统进行的输入&#x2F;输出称为高级磁盘输入&#x2F;输出</li>
<li><code>非缓冲文件系统</code>：系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区，用非缓冲文件系统进行的输入&#x2F;输出称为低级输入&#x2F;输出</li>
</ul>
<p><code>缓冲区</code>其实就是一段内存空间，分为读缓冲，写缓冲，C语言缓冲的三种特性如下：</p>
<ul>
<li><code>全缓冲</code>：在这种情况下，当填满标准I&#x2F;O缓存后才进行实际I&#x2F;O操作。全缓冲的典型代表是对磁盘文件的读写操作</li>
<li><code>行缓冲</code>：在这种情况下，挡在输入和输出中遇到换行符时，将执行真正的I&#x2F;O操作。这时，输入的字符先存放到缓冲区中，等按下回车键换行时才进行实际的I&#x2F;O操作。典型代表是标准输入缓冲区(stdin)和标准输出缓冲区(stdout)</li>
<li><code>不带缓冲</code>：不进行行缓冲，标注出错情况(stderr)是典型代表，这使得出错信息可以直接尽快地显示出来</li>
</ul>
<h2 id="文件的打开，读写，关闭">18.2. 文件的打开，读写，关闭</h2><h3 id="文件指针介绍">18.2.1. 文件指针介绍</h3><p>打开一个文件后，得到一个 <code>FILE*</code>类型的文件指针，然后通过该文件指针对文件进行操作，FILE是一个结构体类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span>&#123;</span></span><br><span class="line">  <span class="comment">//下一个要被读取的字符地址</span></span><br><span class="line">	<span class="type">char</span> *_ptr; </span><br><span class="line">  <span class="comment">//剩余的字符，若是输入缓冲区，则表示缓冲区中含有多少个字符未被读取</span></span><br><span class="line">	<span class="type">int</span> _cnt;</span><br><span class="line">  <span class="comment">// 缓冲区基地址</span></span><br><span class="line">  chat *_base;</span><br><span class="line">  <span class="comment">// 读写状态标志位</span></span><br><span class="line">  <span class="type">int</span> _flag;</span><br><span class="line">  <span class="comment">// 文件描述符</span></span><br><span class="line">  <span class="type">int</span> _file;</span><br><span class="line">  <span class="type">int</span> _charbuff;</span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  <span class="type">int</span> _bufsiz;</span><br><span class="line">  <span class="type">char</span> *_tmpfname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure>

<p>fp是一个指向FILE类型结构体的指针变量，可以使fp只想某个文件的结构体变量，从而通过该结构体变量中的文件信息来访问该文件</p>
<p>Windows操作系统下的FILE结构体与Linux操作系统下的FILE结构体中的变量名是不一致的，但是其原理可以互相参考</p>
<h3 id="文件的打开和关闭">18.2.2. 文件的打开和关闭</h3><p><code>fopen函数</code>用于打开由fname指定的文件，并返回一个关联该文件的流。如果发生错误，那么fopen返回NULL，mode用于决定文件的用途（如输入，输出等），具体形式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname,<span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<p>常用的mode参数及其各自的意义如下所示</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>打开一个用于读取的文本文件</td>
</tr>
<tr>
<td>w</td>
<td>创建一个用于写入的文本文件</td>
</tr>
<tr>
<td>a</td>
<td>附加到一个文本文件</td>
</tr>
<tr>
<td>rb</td>
<td>打开一个用于读取的二进制文件</td>
</tr>
<tr>
<td>wb</td>
<td>创建一个用于写入的二进制文件</td>
</tr>
<tr>
<td>ab</td>
<td>附加到一个二进制文件</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个用于读&#x2F;写的文本文件</td>
</tr>
<tr>
<td>w+</td>
<td>创建一个用于读&#x2F;写的文本文件</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个用于读&#x2F;写的文本文件</td>
</tr>
<tr>
<td>rb+</td>
<td>打开一个用于读&#x2F;写的二进制文件</td>
</tr>
<tr>
<td>wb+</td>
<td>创建一个用于读&#x2F;写的二进制文件</td>
</tr>
<tr>
<td>ab+</td>
<td>打开一个用于读&#x2F;写的二进制文件</td>
</tr>
</tbody></table>
<p><code>fclose函数</code>用于关闭给出的文件流，并释放已关联到流的所有缓冲区。fclose执行成功时返回0，否则返回EOF，具体形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fputc函数</code>用于将字符ch的值输出到fp指向的文件中，如果输出成功，那么返回输出的字符；如果输出失败，那么返回EOF，具体形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetc函数</code>用于从指定的文件中读入一个字符，该文件必须是以读或者读写方式打开的。如果读取一个字符成功，那么赋给ch。如果遇到文件结束符，那么返回文件结束标志EOF，具体形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<p><code>输出文本内容</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取内容</span></span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">fgetc</span>(fp))!=EOF)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>main函数传递参数</strong></p>
<p>假设编译后的可执行文件为test.exe，执行test.exe时，后面跟的参数均是字符串，argv[i]依次指向每个元素，注意参数之间以空格隔开。例如test.exe file1 file2，此时argv[0]是test.exe，argv[1]是file1.txt，argv[2]是file2.txt。</p>
<p>文件名用argv[1]进行传递，打开文件后，得到文件指针fp，如果文件指针fp为NULL，那么表示打开失败，这时可用perror函数得到打开失败的原因，如果未新建一个文件，即文件不存在，那么会出现失败提示。</p>
<p><code>perror(fopen)</code></p>
<p>出现的错误为 fopen: No such file or directory</p>
<p>冒号之前的内容是写入在perror函数的字符串，冒号之后的内容是perror提示的函数失败原因。</p>
<p><code>fgetc</code></p>
<p>文件打开成功后，使用fgetc函数可以读取文件的每个字符。然后循环打印整个文件，读到文件结尾时返回EOF，所以通过判断返回值是否等于EOF就可以确定是否读到问价结尾。</p>
</blockquote>
<p><code>写入到文本</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;文件不存在\n&quot;);  </span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">fputc</span>(<span class="string">&#x27;A&#x27;</span>,fp);</span><br><span class="line">    <span class="keyword">if</span>(ret==EOF)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//65</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fread，fwrite函数">18.2.3. fread，fwrite函数</h3><p><code>fread函数</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">size_t</span> size,<span class="type">size_t</span> num,FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fwrite函数</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buffer,<span class="type">size_t</span> size, <span class="type">size_t</span> count,FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>buffer是一个指针，对fread来说它是读入数据的存放地址，对fwrite来说它是输出谁的地址(均指起始地址)；</p>
<p>size是要读写的字节数；</p>
<p>count是要进行读写多少size字节的数据项；</p>
<p>fread函数的返回值是读取的内容数量；fwrite写成功后的返回值是已写对象的数量</p>
<p><code>具体实现fread+fwrite</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    ch = <span class="built_in">fread</span>(buff,<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">if</span>(ch!=EOF)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(buff);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 写</span></span><br><span class="line">    FILE *fp1 = <span class="built_in">fopen</span>(argv[<span class="number">2</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(buff,<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="built_in">strlen</span>(buff),fp1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><code>fseek函数</code></p>
<p>改变文件的位置指针，其具体调用形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream,<span class="type">long</span> offset,<span class="type">int</span> origin)</span>;</span><br></pre></td></tr></table></figure>

<p>其中 fseek的说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(文件类型指针，位移量，起始点);</span><br></pre></td></tr></table></figure>

<p><code>起始点</code></p>
<blockquote>
<p>文件开头 SEEK_SET 0</p>
<p>当前位置 SEEK_CUR 1</p>
<p>文件末尾 SEEK_END 2</p>
</blockquote>
<p>位移量是指以起始点为基点，向前移动的字节数，一般要求为long型，fseek函数调用成功返回零，调用失败时返回非零</p>
<p><code>存储问题</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    FILE *fp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123; </span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    fwrite(&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>),<span class="number">1</span>,fp);</span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    fread(&amp;j,<span class="keyword">sizeof</span>(<span class="type">int</span>),<span class="number">1</span>,fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j=%d\n&quot;</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件内容为：<img src="/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/a.txt.png"></p>
<p>文件中存储的是ASCII表中十进制9的对应转义字符 \t(横向制表符)</p>
<p>用【hex Editor插件】打开文件内容为09 00 00 00</p>
<p>fread 和 fwrite函数既可以以文本方式对文件进行读写，又可以以二进制方式对文件进行读写，以“r+”即文本方式打开文件进行读写时，向文件内写入9，写入完毕后会将文件位置指针指向4字节的位置，如果要从文件头读取，那么就必须通过fseek函数偏移到文件头。</p>
</blockquote>
<h3 id="fgets，fpus函数">18.2.4. fgets，fpus函数</h3><p><code>fgets函数</code>从给出的文件流中读取[num-1]个字符，并且把它们转储到str(字符串)中，fgets在到达行末时停止，fgets成功时返回str(字符串)，失败时返回NULL，读到文件结尾时返回NULL，其具体形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> num, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>使用fgets函数可以一次读取文件的一行，这样就可以轻松地统计文件的行数，同时，读取一行字符串后，可以按照自己的方式进行单词分割当操作，注意，在做一些在线评测题目时，用于fgets函数的str不能过小，否则可能无法读取”\n“，导致行数统计出错。</p>
<p><code>fpus函数</code>把str(字符串)指向的字符写到给出的输出流，成功时返回非负值，失败时返回EOF，其具体形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> *str, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fputs函数向文件中写入一个字符串，不会额外写入一个”\n“。</p>
<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>],<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(buff,<span class="built_in">sizeof</span>(buff),fp)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// puts(buff);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s&quot;,buff);</span></span><br><span class="line">        <span class="built_in">fputs</span>(buff,stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ftell函数">18.2.5. ftell函数</h3><p>ftell函数返回stream当前的文件位置，发生错误时返回-1，想知道位置指针距离文件开头的位置时，就需要用到ftell函数，其具体形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>ftell与fseek使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello\nWorld&quot;</span>;</span><br><span class="line">    <span class="built_in">fwrite</span>(str,<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="built_in">strlen</span>(str),fp);</span><br><span class="line">    <span class="comment">//偏移5字节</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">-5</span>,SEEK_CUR);</span><br><span class="line">    <span class="comment">//得到当前光标位置</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">ftell</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前位置：%d\n&quot;</span>,pos);</span><br><span class="line">		<span class="comment">// 重新读取内容</span></span><br><span class="line">    <span class="built_in">memset</span>(str,<span class="number">0</span>,<span class="built_in">sizeof</span>(str));</span><br><span class="line">    <span class="built_in">fread</span>(str,<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="built_in">sizeof</span>(str),fp);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>向文件中写入”hello\nworld“，因为是文本方式，所以总计11字节，通过fseek函数向前偏移5字节后，用ftell函数得到的位置指针距离文件开头即为7，这时再用fread函数读取文件内容，得到的是”world“。</p>
</blockquote>

    </div>

    
    
    

    <div>      <div>
    
        <div style="margin-top:30px;padding-top:20px;border-top: 1px dashed #b3a9a7;text-align:center;color: #ccc;font-size:20px;">本文结束&nbsp;<i class="fa fa-paw"></i>&nbsp;感谢您的阅读</div>
    
</div>  </div>
        

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Wang Ting
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <!-- <a href="https://wtlumos.github.io/zh-CN/2018/01/23/%E7%8E%8B%E9%81%93C%E8%AF%AD%E8%A8%80/" title="王道C语言">https://wtlumos.github.io/zh-CN/2018/01/23/王道C语言/</a> -->
    
       <a href ="/zh-CN/2018/01/23/王道C语言/" >/zh-CN/2018/01/23/王道C语言/</a>
  </li>
       <li>
          <strong>发布时间：</strong>
          2018-01-23 13:38
      </li>
      <li>
          <strong>更新时间：</strong>
          2023-04-15 16:18

      </li>
  
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zh-CN/2018/01/24/VSCode%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%80%89%E6%8B%A9/" rel="prev" title="VSCode安装使用及插件选择">
      <i class="fa fa-chevron-left"></i> VSCode安装使用及插件选择
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80"><span class="nav-text">1. C语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX"><span class="nav-text">1.1. UNIX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-text">1.2. C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-text">1.3. 编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%E5%90%8E%E7%9A%84%E5%A2%83%E7%95%8C"><span class="nav-text">1.4. 学习C语言后的境界</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BD%AF%E4%BB%B6VSCode"><span class="nav-text">2. 编译软件VSCode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6"><span class="nav-text">2.1. 下载软件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="nav-text">2.2. 安装插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E6%96%87%E6%A1%A3"><span class="nav-text">2.3. 新建文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BC%96%E8%AF%91"><span class="nav-text">2.4. 启动编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81scanf%E5%87%BD%E6%95%B0"><span class="nav-text">2.5. 支持scanf函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="nav-text">2.6. 查看内存信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%92%8C%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-text">2.7. 查看汇编代码和机器码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E8%AF%AD%E8%A8%80%E5%8C%85"><span class="nav-text">3. 在线语言包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">4. 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text">5. 常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">6. 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-text">6.1. 含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">6.2. 命名规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">7. 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text">7.1. 整型变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F"><span class="nav-text">7.1.1. 符号常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-text">7.1.2. 不同进制表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E7%A7%8D%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.1.3. 6种整型变量类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="nav-text">7.2. 浮点型数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-text">7.2.1. 浮点型常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6"><span class="nav-text">7.2.2. 浮点数精度控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text">7.2.3. 浮点型变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="nav-text">7.3. 字符型数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-text">7.3.1. 字符型常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII%E7%A0%81%E8%A1%A8"><span class="nav-text">7.3.2. ASCII码表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">7.3.3. 字符数据在内存中的存储形式及其使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-text">7.3.4. 字符串型常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97"><span class="nav-text">7.4. 混合运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%8C%89int%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="nav-text">7.4.1. 数值按int型运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%B8%B8%E9%87%8F%E9%BB%98%E8%AE%A4%E6%8C%89double%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="nav-text">7.4.2. 浮点型常量默认按double型运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%9C%BA%E6%99%AF"><span class="nav-text">7.5. 类型强制转换场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">7.6. 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A0%BC%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">7.6.1. 一维数组格式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">7.6.2. 一维数组在内存中的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-text">7.6.3. 一维数组的初始化方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-text">7.6.4. 字符数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-text">7.7. 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">7.7.1. 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E5%8F%96%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">7.7.2. 取地址操作符与取值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">7.7.3. 注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">7.7.4. 指针使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-text">7.7.4.1. 指针的传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB"><span class="nav-text">7.7.4.2. 指针的偏移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E8%87%AA%E5%A2%9E%EF%BC%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">7.7.4.3. 指针与自增，自减运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="nav-text">7.7.5. 指针与动态内存申请</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc%E5%87%BD%E6%95%B0"><span class="nav-text">7.7.5.1. malloc函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="nav-text">7.7.5.2. 栈空间，堆空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free%E5%87%BD%E6%95%B0"><span class="nav-text">7.7.5.3. free函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-text">7.7.6. 字符指针与字符数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-text">7.7.7. 二级指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">8. 字符串操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strlen-%E7%BB%9F%E8%AE%A1%E9%95%BF%E5%BA%A6"><span class="nav-text">8.1. strlen 统计长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strcpy-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="nav-text">8.2. strcpy 复制数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strcmp-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="nav-text">8.3. strcmp 比较大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strcat-%E8%BF%9E%E6%8E%A5"><span class="nav-text">8.4. strcat 连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-text">9. 常用的数据输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scanf%E5%87%BD%E6%95%B0"><span class="nav-text">9.1. scanf函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">9.1.1. 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BC%93%E5%86%B2"><span class="nav-text">9.1.2. 行缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-text">9.1.3. 具体代码格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96"><span class="nav-text">9.1.4. 循环读取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#printf%E5%87%BD%E6%95%B0"><span class="nav-text">9.2. printf函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getchar%E5%87%BD%E6%95%B0"><span class="nav-text">9.3. getchar函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#putchar%E5%87%BD%E6%95%B0"><span class="nav-text">9.4. putchar函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gets%E5%87%BD%E6%95%B0"><span class="nav-text">9.5. gets函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fgets%E5%87%BD%E6%95%B0"><span class="nav-text">9.6. fgets函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#puts%E5%87%BD%E6%95%B0"><span class="nav-text">9.7. puts函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10. 运算符与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%88%86%E7%B1%BB"><span class="nav-text">10.1. 运算符分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E7%AC%A6%E5%8F%B7%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">10.2. C语言符号优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.3. 算术运算符及算数表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.4. 关系运算符及关系表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.5. 逻辑运算符与逻辑表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">10.6. 位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%88%96-%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E5%80%BC"><span class="nav-text">10.6.1. 异或-交换变量值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-%E6%9C%80%E4%BD%8E%E4%BD%8D%E4%B8%BA1%E7%9A%84%E6%95%B4%E6%95%B0"><span class="nav-text">10.6.2. 与-最低位为1的整数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">10.7. 赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">10.8. 复合赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">10.9. 条件运算符与逗号运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%EF%BC%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">10.10. 自增，自减运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">11. 选择结构程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">11.1. 关系表达式与逻辑表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-text">11.2. if语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-text">11.3. switch语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">12. 循环结构程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-text">12.1. while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-x2F-while%E5%BE%AA%E7%8E%AF"><span class="nav-text">12.2. do&#x2F;while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-text">12.3. for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#continue"><span class="nav-text">12.4. continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break"><span class="nav-text">12.5. break</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">13. 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">13.1. 示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="nav-text">13.2. C语言的编译和执行特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-text">13.3. 函数的声明与定义的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="nav-text">13.4. 函数的分类与调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text">13.5. 全局变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-text">13.5.1. 全局变量存储在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="nav-text">13.5.2. 形参和实参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">13.6. 变量及函数的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">13.6.1. 局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">13.6.2. 外部变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">14. 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">14.1. 结构体的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-text">14.2. 结构体指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typedef"><span class="nav-text">15. typedef</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">16. C++的引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const"><span class="nav-text">17. const</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const-char-ptr"><span class="nav-text">17.1. const char *ptr;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char-const-ptr"><span class="nav-text">17.2. char * const ptr;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">18. 文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">18.1. C文件概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%EF%BC%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E5%85%B3%E9%97%AD"><span class="nav-text">18.2. 文件的打开，读写，关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D"><span class="nav-text">18.2.1. 文件指针介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="nav-text">18.2.2. 文件的打开和关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fread%EF%BC%8Cfwrite%E5%87%BD%E6%95%B0"><span class="nav-text">18.2.3. fread，fwrite函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fgets%EF%BC%8Cfpus%E5%87%BD%E6%95%B0"><span class="nav-text">18.2.4. fgets，fpus函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftell%E5%87%BD%E6%95%B0"><span class="nav-text">18.2.5. ftell函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Ting"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wang Ting</p>
  <div class="site-description" itemprop="description">技术成长笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">381</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WTlumos" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WTlumos" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/7807823198" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7807823198" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-glasses fa-fw"></i>
      最近阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/av77638697/" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av77638697&#x2F;" rel="noopener" target="_blank">浙江大学-研究生机器学习课程</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Ting</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span>网站总字数: </span>
    <span title="站点总字数">2.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
        <span>阅读总时长: </span>
    <span title="站点阅读时长">44:22</span>
</div>

<span id="sitetime"></span>

<script language=javascript>
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2018,07,01,00,00,00); //北京时间2018-07-01 00:00:00
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);

    if(window.location.pathname=='/en/'){
           document.getElementById("sitetime").innerHTML=" Run for "+ diffYears+" Year "+ diffDays+" Days "+diffHours+" Hours "+diffMinutes+" Minute "+diffSeconds+" Second";
    }else{
          document.getElementById("sitetime").innerHTML=" 已运行 "+ diffYears+" 年 "+ diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
    }

  }
  siteTime();
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'fb5f16fdf7649a9e5208',
      clientSecret: 'bcd95c87cdbab8fa32fc1b006fbb1ce7e8ffae5b',
      repo        : 'wtlumos.github.io',
      owner       : 'WTlumos',
      admin       : ['WTlumos'],
      id          : '79cd1b546fbcc3c0c7dc249a9c36dac3',
        language: '',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":125,"height":290,"hOffset":-15,"vOffset":-40},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.7},"dialog":{"enable":false,"hitokoto":false},"log":false});</script></body>
</html>
